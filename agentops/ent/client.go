// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/agentplexus/omniobserve/agentops/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/agentplexus/omniobserve/agentops/ent/agentevent"
	"github.com/agentplexus/omniobserve/agentops/ent/agenthandoff"
	"github.com/agentplexus/omniobserve/agentops/ent/agenttask"
	"github.com/agentplexus/omniobserve/agentops/ent/toolinvocation"
	"github.com/agentplexus/omniobserve/agentops/ent/workflow"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AgentEvent is the client for interacting with the AgentEvent builders.
	AgentEvent *AgentEventClient
	// AgentHandoff is the client for interacting with the AgentHandoff builders.
	AgentHandoff *AgentHandoffClient
	// AgentTask is the client for interacting with the AgentTask builders.
	AgentTask *AgentTaskClient
	// ToolInvocation is the client for interacting with the ToolInvocation builders.
	ToolInvocation *ToolInvocationClient
	// Workflow is the client for interacting with the Workflow builders.
	Workflow *WorkflowClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AgentEvent = NewAgentEventClient(c.config)
	c.AgentHandoff = NewAgentHandoffClient(c.config)
	c.AgentTask = NewAgentTaskClient(c.config)
	c.ToolInvocation = NewToolInvocationClient(c.config)
	c.Workflow = NewWorkflowClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		AgentEvent:     NewAgentEventClient(cfg),
		AgentHandoff:   NewAgentHandoffClient(cfg),
		AgentTask:      NewAgentTaskClient(cfg),
		ToolInvocation: NewToolInvocationClient(cfg),
		Workflow:       NewWorkflowClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		AgentEvent:     NewAgentEventClient(cfg),
		AgentHandoff:   NewAgentHandoffClient(cfg),
		AgentTask:      NewAgentTaskClient(cfg),
		ToolInvocation: NewToolInvocationClient(cfg),
		Workflow:       NewWorkflowClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AgentEvent.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.AgentEvent.Use(hooks...)
	c.AgentHandoff.Use(hooks...)
	c.AgentTask.Use(hooks...)
	c.ToolInvocation.Use(hooks...)
	c.Workflow.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.AgentEvent.Intercept(interceptors...)
	c.AgentHandoff.Intercept(interceptors...)
	c.AgentTask.Intercept(interceptors...)
	c.ToolInvocation.Intercept(interceptors...)
	c.Workflow.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AgentEventMutation:
		return c.AgentEvent.mutate(ctx, m)
	case *AgentHandoffMutation:
		return c.AgentHandoff.mutate(ctx, m)
	case *AgentTaskMutation:
		return c.AgentTask.mutate(ctx, m)
	case *ToolInvocationMutation:
		return c.ToolInvocation.mutate(ctx, m)
	case *WorkflowMutation:
		return c.Workflow.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AgentEventClient is a client for the AgentEvent schema.
type AgentEventClient struct {
	config
}

// NewAgentEventClient returns a client for the AgentEvent from the given config.
func NewAgentEventClient(c config) *AgentEventClient {
	return &AgentEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agentevent.Hooks(f(g(h())))`.
func (c *AgentEventClient) Use(hooks ...Hook) {
	c.hooks.AgentEvent = append(c.hooks.AgentEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agentevent.Intercept(f(g(h())))`.
func (c *AgentEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentEvent = append(c.inters.AgentEvent, interceptors...)
}

// Create returns a builder for creating a AgentEvent entity.
func (c *AgentEventClient) Create() *AgentEventCreate {
	mutation := newAgentEventMutation(c.config, OpCreate)
	return &AgentEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentEvent entities.
func (c *AgentEventClient) CreateBulk(builders ...*AgentEventCreate) *AgentEventCreateBulk {
	return &AgentEventCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentEventClient) MapCreateBulk(slice any, setFunc func(*AgentEventCreate, int)) *AgentEventCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentEventCreateBulk{err: fmt.Errorf("calling to AgentEventClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentEventCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentEvent.
func (c *AgentEventClient) Update() *AgentEventUpdate {
	mutation := newAgentEventMutation(c.config, OpUpdate)
	return &AgentEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentEventClient) UpdateOne(ae *AgentEvent) *AgentEventUpdateOne {
	mutation := newAgentEventMutation(c.config, OpUpdateOne, withAgentEvent(ae))
	return &AgentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentEventClient) UpdateOneID(id string) *AgentEventUpdateOne {
	mutation := newAgentEventMutation(c.config, OpUpdateOne, withAgentEventID(id))
	return &AgentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentEvent.
func (c *AgentEventClient) Delete() *AgentEventDelete {
	mutation := newAgentEventMutation(c.config, OpDelete)
	return &AgentEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentEventClient) DeleteOne(ae *AgentEvent) *AgentEventDeleteOne {
	return c.DeleteOneID(ae.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentEventClient) DeleteOneID(id string) *AgentEventDeleteOne {
	builder := c.Delete().Where(agentevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentEventDeleteOne{builder}
}

// Query returns a query builder for AgentEvent.
func (c *AgentEventClient) Query() *AgentEventQuery {
	return &AgentEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentEvent entity by its id.
func (c *AgentEventClient) Get(ctx context.Context, id string) (*AgentEvent, error) {
	return c.Query().Where(agentevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentEventClient) GetX(ctx context.Context, id string) *AgentEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a AgentEvent.
func (c *AgentEventClient) QueryWorkflow(ae *AgentEvent) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentevent.Table, agentevent.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agentevent.WorkflowTable, agentevent.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTask queries the task edge of a AgentEvent.
func (c *AgentEventClient) QueryTask(ae *AgentEvent) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ae.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentevent.Table, agentevent.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agentevent.TaskTable, agentevent.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(ae.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentEventClient) Hooks() []Hook {
	return c.hooks.AgentEvent
}

// Interceptors returns the client interceptors.
func (c *AgentEventClient) Interceptors() []Interceptor {
	return c.inters.AgentEvent
}

func (c *AgentEventClient) mutate(ctx context.Context, m *AgentEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentEvent mutation op: %q", m.Op())
	}
}

// AgentHandoffClient is a client for the AgentHandoff schema.
type AgentHandoffClient struct {
	config
}

// NewAgentHandoffClient returns a client for the AgentHandoff from the given config.
func NewAgentHandoffClient(c config) *AgentHandoffClient {
	return &AgentHandoffClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agenthandoff.Hooks(f(g(h())))`.
func (c *AgentHandoffClient) Use(hooks ...Hook) {
	c.hooks.AgentHandoff = append(c.hooks.AgentHandoff, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agenthandoff.Intercept(f(g(h())))`.
func (c *AgentHandoffClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentHandoff = append(c.inters.AgentHandoff, interceptors...)
}

// Create returns a builder for creating a AgentHandoff entity.
func (c *AgentHandoffClient) Create() *AgentHandoffCreate {
	mutation := newAgentHandoffMutation(c.config, OpCreate)
	return &AgentHandoffCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentHandoff entities.
func (c *AgentHandoffClient) CreateBulk(builders ...*AgentHandoffCreate) *AgentHandoffCreateBulk {
	return &AgentHandoffCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentHandoffClient) MapCreateBulk(slice any, setFunc func(*AgentHandoffCreate, int)) *AgentHandoffCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentHandoffCreateBulk{err: fmt.Errorf("calling to AgentHandoffClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentHandoffCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentHandoffCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentHandoff.
func (c *AgentHandoffClient) Update() *AgentHandoffUpdate {
	mutation := newAgentHandoffMutation(c.config, OpUpdate)
	return &AgentHandoffUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentHandoffClient) UpdateOne(ah *AgentHandoff) *AgentHandoffUpdateOne {
	mutation := newAgentHandoffMutation(c.config, OpUpdateOne, withAgentHandoff(ah))
	return &AgentHandoffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentHandoffClient) UpdateOneID(id string) *AgentHandoffUpdateOne {
	mutation := newAgentHandoffMutation(c.config, OpUpdateOne, withAgentHandoffID(id))
	return &AgentHandoffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentHandoff.
func (c *AgentHandoffClient) Delete() *AgentHandoffDelete {
	mutation := newAgentHandoffMutation(c.config, OpDelete)
	return &AgentHandoffDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentHandoffClient) DeleteOne(ah *AgentHandoff) *AgentHandoffDeleteOne {
	return c.DeleteOneID(ah.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentHandoffClient) DeleteOneID(id string) *AgentHandoffDeleteOne {
	builder := c.Delete().Where(agenthandoff.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentHandoffDeleteOne{builder}
}

// Query returns a query builder for AgentHandoff.
func (c *AgentHandoffClient) Query() *AgentHandoffQuery {
	return &AgentHandoffQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentHandoff},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentHandoff entity by its id.
func (c *AgentHandoffClient) Get(ctx context.Context, id string) (*AgentHandoff, error) {
	return c.Query().Where(agenthandoff.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentHandoffClient) GetX(ctx context.Context, id string) *AgentHandoff {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a AgentHandoff.
func (c *AgentHandoffClient) QueryWorkflow(ah *AgentHandoff) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ah.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenthandoff.Table, agenthandoff.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agenthandoff.WorkflowTable, agenthandoff.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(ah.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentHandoffClient) Hooks() []Hook {
	return c.hooks.AgentHandoff
}

// Interceptors returns the client interceptors.
func (c *AgentHandoffClient) Interceptors() []Interceptor {
	return c.inters.AgentHandoff
}

func (c *AgentHandoffClient) mutate(ctx context.Context, m *AgentHandoffMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentHandoffCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentHandoffUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentHandoffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentHandoffDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentHandoff mutation op: %q", m.Op())
	}
}

// AgentTaskClient is a client for the AgentTask schema.
type AgentTaskClient struct {
	config
}

// NewAgentTaskClient returns a client for the AgentTask from the given config.
func NewAgentTaskClient(c config) *AgentTaskClient {
	return &AgentTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agenttask.Hooks(f(g(h())))`.
func (c *AgentTaskClient) Use(hooks ...Hook) {
	c.hooks.AgentTask = append(c.hooks.AgentTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agenttask.Intercept(f(g(h())))`.
func (c *AgentTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentTask = append(c.inters.AgentTask, interceptors...)
}

// Create returns a builder for creating a AgentTask entity.
func (c *AgentTaskClient) Create() *AgentTaskCreate {
	mutation := newAgentTaskMutation(c.config, OpCreate)
	return &AgentTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentTask entities.
func (c *AgentTaskClient) CreateBulk(builders ...*AgentTaskCreate) *AgentTaskCreateBulk {
	return &AgentTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentTaskClient) MapCreateBulk(slice any, setFunc func(*AgentTaskCreate, int)) *AgentTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentTaskCreateBulk{err: fmt.Errorf("calling to AgentTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentTask.
func (c *AgentTaskClient) Update() *AgentTaskUpdate {
	mutation := newAgentTaskMutation(c.config, OpUpdate)
	return &AgentTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentTaskClient) UpdateOne(at *AgentTask) *AgentTaskUpdateOne {
	mutation := newAgentTaskMutation(c.config, OpUpdateOne, withAgentTask(at))
	return &AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentTaskClient) UpdateOneID(id string) *AgentTaskUpdateOne {
	mutation := newAgentTaskMutation(c.config, OpUpdateOne, withAgentTaskID(id))
	return &AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentTask.
func (c *AgentTaskClient) Delete() *AgentTaskDelete {
	mutation := newAgentTaskMutation(c.config, OpDelete)
	return &AgentTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentTaskClient) DeleteOne(at *AgentTask) *AgentTaskDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentTaskClient) DeleteOneID(id string) *AgentTaskDeleteOne {
	builder := c.Delete().Where(agenttask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentTaskDeleteOne{builder}
}

// Query returns a query builder for AgentTask.
func (c *AgentTaskClient) Query() *AgentTaskQuery {
	return &AgentTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentTask},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentTask entity by its id.
func (c *AgentTaskClient) Get(ctx context.Context, id string) (*AgentTask, error) {
	return c.Query().Where(agenttask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentTaskClient) GetX(ctx context.Context, id string) *AgentTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a AgentTask.
func (c *AgentTaskClient) QueryWorkflow(at *AgentTask) *WorkflowQuery {
	query := (&WorkflowClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agenttask.WorkflowTable, agenttask.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToolInvocations queries the tool_invocations edge of a AgentTask.
func (c *AgentTaskClient) QueryToolInvocations(at *AgentTask) *ToolInvocationQuery {
	query := (&ToolInvocationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(toolinvocation.Table, toolinvocation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agenttask.ToolInvocationsTable, agenttask.ToolInvocationsColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a AgentTask.
func (c *AgentTaskClient) QueryEvents(at *AgentTask) *AgentEventQuery {
	query := (&AgentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(agentevent.Table, agentevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, agenttask.EventsTable, agenttask.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentTaskClient) Hooks() []Hook {
	return c.hooks.AgentTask
}

// Interceptors returns the client interceptors.
func (c *AgentTaskClient) Interceptors() []Interceptor {
	return c.inters.AgentTask
}

func (c *AgentTaskClient) mutate(ctx context.Context, m *AgentTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentTask mutation op: %q", m.Op())
	}
}

// ToolInvocationClient is a client for the ToolInvocation schema.
type ToolInvocationClient struct {
	config
}

// NewToolInvocationClient returns a client for the ToolInvocation from the given config.
func NewToolInvocationClient(c config) *ToolInvocationClient {
	return &ToolInvocationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `toolinvocation.Hooks(f(g(h())))`.
func (c *ToolInvocationClient) Use(hooks ...Hook) {
	c.hooks.ToolInvocation = append(c.hooks.ToolInvocation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `toolinvocation.Intercept(f(g(h())))`.
func (c *ToolInvocationClient) Intercept(interceptors ...Interceptor) {
	c.inters.ToolInvocation = append(c.inters.ToolInvocation, interceptors...)
}

// Create returns a builder for creating a ToolInvocation entity.
func (c *ToolInvocationClient) Create() *ToolInvocationCreate {
	mutation := newToolInvocationMutation(c.config, OpCreate)
	return &ToolInvocationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ToolInvocation entities.
func (c *ToolInvocationClient) CreateBulk(builders ...*ToolInvocationCreate) *ToolInvocationCreateBulk {
	return &ToolInvocationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ToolInvocationClient) MapCreateBulk(slice any, setFunc func(*ToolInvocationCreate, int)) *ToolInvocationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ToolInvocationCreateBulk{err: fmt.Errorf("calling to ToolInvocationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ToolInvocationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ToolInvocationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ToolInvocation.
func (c *ToolInvocationClient) Update() *ToolInvocationUpdate {
	mutation := newToolInvocationMutation(c.config, OpUpdate)
	return &ToolInvocationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ToolInvocationClient) UpdateOne(ti *ToolInvocation) *ToolInvocationUpdateOne {
	mutation := newToolInvocationMutation(c.config, OpUpdateOne, withToolInvocation(ti))
	return &ToolInvocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ToolInvocationClient) UpdateOneID(id string) *ToolInvocationUpdateOne {
	mutation := newToolInvocationMutation(c.config, OpUpdateOne, withToolInvocationID(id))
	return &ToolInvocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ToolInvocation.
func (c *ToolInvocationClient) Delete() *ToolInvocationDelete {
	mutation := newToolInvocationMutation(c.config, OpDelete)
	return &ToolInvocationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ToolInvocationClient) DeleteOne(ti *ToolInvocation) *ToolInvocationDeleteOne {
	return c.DeleteOneID(ti.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ToolInvocationClient) DeleteOneID(id string) *ToolInvocationDeleteOne {
	builder := c.Delete().Where(toolinvocation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ToolInvocationDeleteOne{builder}
}

// Query returns a query builder for ToolInvocation.
func (c *ToolInvocationClient) Query() *ToolInvocationQuery {
	return &ToolInvocationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToolInvocation},
		inters: c.Interceptors(),
	}
}

// Get returns a ToolInvocation entity by its id.
func (c *ToolInvocationClient) Get(ctx context.Context, id string) (*ToolInvocation, error) {
	return c.Query().Where(toolinvocation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ToolInvocationClient) GetX(ctx context.Context, id string) *ToolInvocation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTask queries the task edge of a ToolInvocation.
func (c *ToolInvocationClient) QueryTask(ti *ToolInvocation) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(toolinvocation.Table, toolinvocation.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, toolinvocation.TaskTable, toolinvocation.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ToolInvocationClient) Hooks() []Hook {
	return c.hooks.ToolInvocation
}

// Interceptors returns the client interceptors.
func (c *ToolInvocationClient) Interceptors() []Interceptor {
	return c.inters.ToolInvocation
}

func (c *ToolInvocationClient) mutate(ctx context.Context, m *ToolInvocationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ToolInvocationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ToolInvocationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ToolInvocationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ToolInvocationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ToolInvocation mutation op: %q", m.Op())
	}
}

// WorkflowClient is a client for the Workflow schema.
type WorkflowClient struct {
	config
}

// NewWorkflowClient returns a client for the Workflow from the given config.
func NewWorkflowClient(c config) *WorkflowClient {
	return &WorkflowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflow.Hooks(f(g(h())))`.
func (c *WorkflowClient) Use(hooks ...Hook) {
	c.hooks.Workflow = append(c.hooks.Workflow, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workflow.Intercept(f(g(h())))`.
func (c *WorkflowClient) Intercept(interceptors ...Interceptor) {
	c.inters.Workflow = append(c.inters.Workflow, interceptors...)
}

// Create returns a builder for creating a Workflow entity.
func (c *WorkflowClient) Create() *WorkflowCreate {
	mutation := newWorkflowMutation(c.config, OpCreate)
	return &WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workflow entities.
func (c *WorkflowClient) CreateBulk(builders ...*WorkflowCreate) *WorkflowCreateBulk {
	return &WorkflowCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkflowClient) MapCreateBulk(slice any, setFunc func(*WorkflowCreate, int)) *WorkflowCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkflowCreateBulk{err: fmt.Errorf("calling to WorkflowClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkflowCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkflowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workflow.
func (c *WorkflowClient) Update() *WorkflowUpdate {
	mutation := newWorkflowMutation(c.config, OpUpdate)
	return &WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowClient) UpdateOne(w *Workflow) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflow(w))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowClient) UpdateOneID(id string) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflowID(id))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workflow.
func (c *WorkflowClient) Delete() *WorkflowDelete {
	mutation := newWorkflowMutation(c.config, OpDelete)
	return &WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkflowClient) DeleteOne(w *Workflow) *WorkflowDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkflowClient) DeleteOneID(id string) *WorkflowDeleteOne {
	builder := c.Delete().Where(workflow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowDeleteOne{builder}
}

// Query returns a query builder for Workflow.
func (c *WorkflowClient) Query() *WorkflowQuery {
	return &WorkflowQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkflow},
		inters: c.Interceptors(),
	}
}

// Get returns a Workflow entity by its id.
func (c *WorkflowClient) Get(ctx context.Context, id string) (*Workflow, error) {
	return c.Query().Where(workflow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowClient) GetX(ctx context.Context, id string) *Workflow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTasks queries the tasks edge of a Workflow.
func (c *WorkflowClient) QueryTasks(w *Workflow) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.TasksTable, workflow.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHandoffs queries the handoffs edge of a Workflow.
func (c *WorkflowClient) QueryHandoffs(w *Workflow) *AgentHandoffQuery {
	query := (&AgentHandoffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(agenthandoff.Table, agenthandoff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.HandoffsTable, workflow.HandoffsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvents queries the events edge of a Workflow.
func (c *WorkflowClient) QueryEvents(w *Workflow) *AgentEventQuery {
	query := (&AgentEventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(agentevent.Table, agentevent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.EventsTable, workflow.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowClient) Hooks() []Hook {
	return c.hooks.Workflow
}

// Interceptors returns the client interceptors.
func (c *WorkflowClient) Interceptors() []Interceptor {
	return c.inters.Workflow
}

func (c *WorkflowClient) mutate(ctx context.Context, m *WorkflowMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Workflow mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AgentEvent, AgentHandoff, AgentTask, ToolInvocation, Workflow []ent.Hook
	}
	inters struct {
		AgentEvent, AgentHandoff, AgentTask, ToolInvocation, Workflow []ent.Interceptor
	}
)
