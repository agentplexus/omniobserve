// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/agentplexus/omniobserve/agentops/ent/agentevent"
	"github.com/agentplexus/omniobserve/agentops/ent/agenthandoff"
	"github.com/agentplexus/omniobserve/agentops/ent/agenttask"
	"github.com/agentplexus/omniobserve/agentops/ent/predicate"
	"github.com/agentplexus/omniobserve/agentops/ent/toolinvocation"
	"github.com/agentplexus/omniobserve/agentops/ent/workflow"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgentEvent     = "AgentEvent"
	TypeAgentHandoff   = "AgentHandoff"
	TypeAgentTask      = "AgentTask"
	TypeToolInvocation = "ToolInvocation"
	TypeWorkflow       = "Workflow"
)

// AgentEventMutation represents an operation that mutates the AgentEvent nodes in the graph.
type AgentEventMutation struct {
	config
	op              Op
	typ             string
	id              *string
	event_type      *string
	event_category  *string
	agent_id        *string
	trace_id        *string
	span_id         *string
	severity        *string
	data            *map[string]interface{}
	metadata        *map[string]interface{}
	tags            *[]string
	appendtags      []string
	source          *string
	version         *string
	timestamp       *time.Time
	created_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *string
	clearedworkflow bool
	task            *string
	clearedtask     bool
	done            bool
	oldValue        func(context.Context) (*AgentEvent, error)
	predicates      []predicate.AgentEvent
}

var _ ent.Mutation = (*AgentEventMutation)(nil)

// agenteventOption allows management of the mutation configuration using functional options.
type agenteventOption func(*AgentEventMutation)

// newAgentEventMutation creates new mutation for the AgentEvent entity.
func newAgentEventMutation(c config, op Op, opts ...agenteventOption) *AgentEventMutation {
	m := &AgentEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentEventID sets the ID field of the mutation.
func withAgentEventID(id string) agenteventOption {
	return func(m *AgentEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentEvent
		)
		m.oldValue = func(ctx context.Context) (*AgentEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentEvent sets the old AgentEvent of the mutation.
func withAgentEvent(node *AgentEvent) agenteventOption {
	return func(m *AgentEventMutation) {
		m.oldValue = func(context.Context) (*AgentEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentEvent entities.
func (m *AgentEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventType sets the "event_type" field.
func (m *AgentEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *AgentEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *AgentEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetEventCategory sets the "event_category" field.
func (m *AgentEventMutation) SetEventCategory(s string) {
	m.event_category = &s
}

// EventCategory returns the value of the "event_category" field in the mutation.
func (m *AgentEventMutation) EventCategory() (r string, exists bool) {
	v := m.event_category
	if v == nil {
		return
	}
	return *v, true
}

// OldEventCategory returns the old "event_category" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldEventCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventCategory: %w", err)
	}
	return oldValue.EventCategory, nil
}

// ResetEventCategory resets all changes to the "event_category" field.
func (m *AgentEventMutation) ResetEventCategory() {
	m.event_category = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *AgentEventMutation) SetWorkflowID(s string) {
	m.workflow = &s
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *AgentEventMutation) WorkflowID() (r string, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldWorkflowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ClearWorkflowID clears the value of the "workflow_id" field.
func (m *AgentEventMutation) ClearWorkflowID() {
	m.workflow = nil
	m.clearedFields[agentevent.FieldWorkflowID] = struct{}{}
}

// WorkflowIDCleared returns if the "workflow_id" field was cleared in this mutation.
func (m *AgentEventMutation) WorkflowIDCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldWorkflowID]
	return ok
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *AgentEventMutation) ResetWorkflowID() {
	m.workflow = nil
	delete(m.clearedFields, agentevent.FieldWorkflowID)
}

// SetTaskID sets the "task_id" field.
func (m *AgentEventMutation) SetTaskID(s string) {
	m.task = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *AgentEventMutation) TaskID() (r string, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *AgentEventMutation) ClearTaskID() {
	m.task = nil
	m.clearedFields[agentevent.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *AgentEventMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *AgentEventMutation) ResetTaskID() {
	m.task = nil
	delete(m.clearedFields, agentevent.FieldTaskID)
}

// SetAgentID sets the "agent_id" field.
func (m *AgentEventMutation) SetAgentID(s string) {
	m.agent_id = &s
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *AgentEventMutation) AgentID() (r string, exists bool) {
	v := m.agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *AgentEventMutation) ClearAgentID() {
	m.agent_id = nil
	m.clearedFields[agentevent.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *AgentEventMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *AgentEventMutation) ResetAgentID() {
	m.agent_id = nil
	delete(m.clearedFields, agentevent.FieldAgentID)
}

// SetTraceID sets the "trace_id" field.
func (m *AgentEventMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *AgentEventMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *AgentEventMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[agentevent.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *AgentEventMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *AgentEventMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, agentevent.FieldTraceID)
}

// SetSpanID sets the "span_id" field.
func (m *AgentEventMutation) SetSpanID(s string) {
	m.span_id = &s
}

// SpanID returns the value of the "span_id" field in the mutation.
func (m *AgentEventMutation) SpanID() (r string, exists bool) {
	v := m.span_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpanID returns the old "span_id" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldSpanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpanID: %w", err)
	}
	return oldValue.SpanID, nil
}

// ClearSpanID clears the value of the "span_id" field.
func (m *AgentEventMutation) ClearSpanID() {
	m.span_id = nil
	m.clearedFields[agentevent.FieldSpanID] = struct{}{}
}

// SpanIDCleared returns if the "span_id" field was cleared in this mutation.
func (m *AgentEventMutation) SpanIDCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldSpanID]
	return ok
}

// ResetSpanID resets all changes to the "span_id" field.
func (m *AgentEventMutation) ResetSpanID() {
	m.span_id = nil
	delete(m.clearedFields, agentevent.FieldSpanID)
}

// SetSeverity sets the "severity" field.
func (m *AgentEventMutation) SetSeverity(s string) {
	m.severity = &s
}

// Severity returns the value of the "severity" field in the mutation.
func (m *AgentEventMutation) Severity() (r string, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldSeverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *AgentEventMutation) ResetSeverity() {
	m.severity = nil
}

// SetData sets the "data" field.
func (m *AgentEventMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *AgentEventMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *AgentEventMutation) ClearData() {
	m.data = nil
	m.clearedFields[agentevent.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *AgentEventMutation) DataCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *AgentEventMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, agentevent.FieldData)
}

// SetMetadata sets the "metadata" field.
func (m *AgentEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AgentEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AgentEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[agentevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AgentEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AgentEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, agentevent.FieldMetadata)
}

// SetTags sets the "tags" field.
func (m *AgentEventMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AgentEventMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AgentEventMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AgentEventMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *AgentEventMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[agentevent.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *AgentEventMutation) TagsCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *AgentEventMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, agentevent.FieldTags)
}

// SetSource sets the "source" field.
func (m *AgentEventMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AgentEventMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *AgentEventMutation) ClearSource() {
	m.source = nil
	m.clearedFields[agentevent.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *AgentEventMutation) SourceCleared() bool {
	_, ok := m.clearedFields[agentevent.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *AgentEventMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, agentevent.FieldSource)
}

// SetVersion sets the "version" field.
func (m *AgentEventMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AgentEventMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AgentEventMutation) ResetVersion() {
	m.version = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *AgentEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AgentEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AgentEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AgentEvent entity.
// If the AgentEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *AgentEventMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[agentevent.FieldWorkflowID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *AgentEventMutation) WorkflowCleared() bool {
	return m.WorkflowIDCleared() || m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *AgentEventMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *AgentEventMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// ClearTask clears the "task" edge to the AgentTask entity.
func (m *AgentEventMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[agentevent.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the AgentTask entity was cleared.
func (m *AgentEventMutation) TaskCleared() bool {
	return m.TaskIDCleared() || m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *AgentEventMutation) TaskIDs() (ids []string) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *AgentEventMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the AgentEventMutation builder.
func (m *AgentEventMutation) Where(ps ...predicate.AgentEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentEvent).
func (m *AgentEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentEventMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.event_type != nil {
		fields = append(fields, agentevent.FieldEventType)
	}
	if m.event_category != nil {
		fields = append(fields, agentevent.FieldEventCategory)
	}
	if m.workflow != nil {
		fields = append(fields, agentevent.FieldWorkflowID)
	}
	if m.task != nil {
		fields = append(fields, agentevent.FieldTaskID)
	}
	if m.agent_id != nil {
		fields = append(fields, agentevent.FieldAgentID)
	}
	if m.trace_id != nil {
		fields = append(fields, agentevent.FieldTraceID)
	}
	if m.span_id != nil {
		fields = append(fields, agentevent.FieldSpanID)
	}
	if m.severity != nil {
		fields = append(fields, agentevent.FieldSeverity)
	}
	if m.data != nil {
		fields = append(fields, agentevent.FieldData)
	}
	if m.metadata != nil {
		fields = append(fields, agentevent.FieldMetadata)
	}
	if m.tags != nil {
		fields = append(fields, agentevent.FieldTags)
	}
	if m.source != nil {
		fields = append(fields, agentevent.FieldSource)
	}
	if m.version != nil {
		fields = append(fields, agentevent.FieldVersion)
	}
	if m.timestamp != nil {
		fields = append(fields, agentevent.FieldTimestamp)
	}
	if m.created_at != nil {
		fields = append(fields, agentevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentevent.FieldEventType:
		return m.EventType()
	case agentevent.FieldEventCategory:
		return m.EventCategory()
	case agentevent.FieldWorkflowID:
		return m.WorkflowID()
	case agentevent.FieldTaskID:
		return m.TaskID()
	case agentevent.FieldAgentID:
		return m.AgentID()
	case agentevent.FieldTraceID:
		return m.TraceID()
	case agentevent.FieldSpanID:
		return m.SpanID()
	case agentevent.FieldSeverity:
		return m.Severity()
	case agentevent.FieldData:
		return m.Data()
	case agentevent.FieldMetadata:
		return m.Metadata()
	case agentevent.FieldTags:
		return m.Tags()
	case agentevent.FieldSource:
		return m.Source()
	case agentevent.FieldVersion:
		return m.Version()
	case agentevent.FieldTimestamp:
		return m.Timestamp()
	case agentevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentevent.FieldEventType:
		return m.OldEventType(ctx)
	case agentevent.FieldEventCategory:
		return m.OldEventCategory(ctx)
	case agentevent.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case agentevent.FieldTaskID:
		return m.OldTaskID(ctx)
	case agentevent.FieldAgentID:
		return m.OldAgentID(ctx)
	case agentevent.FieldTraceID:
		return m.OldTraceID(ctx)
	case agentevent.FieldSpanID:
		return m.OldSpanID(ctx)
	case agentevent.FieldSeverity:
		return m.OldSeverity(ctx)
	case agentevent.FieldData:
		return m.OldData(ctx)
	case agentevent.FieldMetadata:
		return m.OldMetadata(ctx)
	case agentevent.FieldTags:
		return m.OldTags(ctx)
	case agentevent.FieldSource:
		return m.OldSource(ctx)
	case agentevent.FieldVersion:
		return m.OldVersion(ctx)
	case agentevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case agentevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AgentEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case agentevent.FieldEventCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventCategory(v)
		return nil
	case agentevent.FieldWorkflowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case agentevent.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case agentevent.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case agentevent.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case agentevent.FieldSpanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpanID(v)
		return nil
	case agentevent.FieldSeverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case agentevent.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case agentevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case agentevent.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case agentevent.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case agentevent.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case agentevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case agentevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AgentEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AgentEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agentevent.FieldWorkflowID) {
		fields = append(fields, agentevent.FieldWorkflowID)
	}
	if m.FieldCleared(agentevent.FieldTaskID) {
		fields = append(fields, agentevent.FieldTaskID)
	}
	if m.FieldCleared(agentevent.FieldAgentID) {
		fields = append(fields, agentevent.FieldAgentID)
	}
	if m.FieldCleared(agentevent.FieldTraceID) {
		fields = append(fields, agentevent.FieldTraceID)
	}
	if m.FieldCleared(agentevent.FieldSpanID) {
		fields = append(fields, agentevent.FieldSpanID)
	}
	if m.FieldCleared(agentevent.FieldData) {
		fields = append(fields, agentevent.FieldData)
	}
	if m.FieldCleared(agentevent.FieldMetadata) {
		fields = append(fields, agentevent.FieldMetadata)
	}
	if m.FieldCleared(agentevent.FieldTags) {
		fields = append(fields, agentevent.FieldTags)
	}
	if m.FieldCleared(agentevent.FieldSource) {
		fields = append(fields, agentevent.FieldSource)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentEventMutation) ClearField(name string) error {
	switch name {
	case agentevent.FieldWorkflowID:
		m.ClearWorkflowID()
		return nil
	case agentevent.FieldTaskID:
		m.ClearTaskID()
		return nil
	case agentevent.FieldAgentID:
		m.ClearAgentID()
		return nil
	case agentevent.FieldTraceID:
		m.ClearTraceID()
		return nil
	case agentevent.FieldSpanID:
		m.ClearSpanID()
		return nil
	case agentevent.FieldData:
		m.ClearData()
		return nil
	case agentevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	case agentevent.FieldTags:
		m.ClearTags()
		return nil
	case agentevent.FieldSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown AgentEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentEventMutation) ResetField(name string) error {
	switch name {
	case agentevent.FieldEventType:
		m.ResetEventType()
		return nil
	case agentevent.FieldEventCategory:
		m.ResetEventCategory()
		return nil
	case agentevent.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case agentevent.FieldTaskID:
		m.ResetTaskID()
		return nil
	case agentevent.FieldAgentID:
		m.ResetAgentID()
		return nil
	case agentevent.FieldTraceID:
		m.ResetTraceID()
		return nil
	case agentevent.FieldSpanID:
		m.ResetSpanID()
		return nil
	case agentevent.FieldSeverity:
		m.ResetSeverity()
		return nil
	case agentevent.FieldData:
		m.ResetData()
		return nil
	case agentevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case agentevent.FieldTags:
		m.ResetTags()
		return nil
	case agentevent.FieldSource:
		m.ResetSource()
		return nil
	case agentevent.FieldVersion:
		m.ResetVersion()
		return nil
	case agentevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case agentevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AgentEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, agentevent.EdgeWorkflow)
	}
	if m.task != nil {
		edges = append(edges, agentevent.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agentevent.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case agentevent.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, agentevent.EdgeWorkflow)
	}
	if m.clearedtask {
		edges = append(edges, agentevent.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentEventMutation) EdgeCleared(name string) bool {
	switch name {
	case agentevent.EdgeWorkflow:
		return m.clearedworkflow
	case agentevent.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentEventMutation) ClearEdge(name string) error {
	switch name {
	case agentevent.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case agentevent.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown AgentEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentEventMutation) ResetEdge(name string) error {
	switch name {
	case agentevent.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case agentevent.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown AgentEvent edge %s", name)
}

// AgentHandoffMutation represents an operation that mutates the AgentHandoff nodes in the graph.
type AgentHandoffMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	from_agent_id         *string
	from_agent_type       *string
	to_agent_id           *string
	to_agent_type         *string
	handoff_type          *string
	status                *string
	trace_id              *string
	from_task_id          *string
	to_task_id            *string
	payload               *map[string]interface{}
	metadata              *map[string]interface{}
	payload_size_bytes    *int
	addpayload_size_bytes *int
	latency_ms            *int64
	addlatency_ms         *int64
	error_message         *string
	initiated_at          *time.Time
	accepted_at           *time.Time
	completed_at          *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	workflow              *string
	clearedworkflow       bool
	done                  bool
	oldValue              func(context.Context) (*AgentHandoff, error)
	predicates            []predicate.AgentHandoff
}

var _ ent.Mutation = (*AgentHandoffMutation)(nil)

// agenthandoffOption allows management of the mutation configuration using functional options.
type agenthandoffOption func(*AgentHandoffMutation)

// newAgentHandoffMutation creates new mutation for the AgentHandoff entity.
func newAgentHandoffMutation(c config, op Op, opts ...agenthandoffOption) *AgentHandoffMutation {
	m := &AgentHandoffMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentHandoff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentHandoffID sets the ID field of the mutation.
func withAgentHandoffID(id string) agenthandoffOption {
	return func(m *AgentHandoffMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentHandoff
		)
		m.oldValue = func(ctx context.Context) (*AgentHandoff, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentHandoff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentHandoff sets the old AgentHandoff of the mutation.
func withAgentHandoff(node *AgentHandoff) agenthandoffOption {
	return func(m *AgentHandoffMutation) {
		m.oldValue = func(context.Context) (*AgentHandoff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentHandoffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentHandoffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentHandoff entities.
func (m *AgentHandoffMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentHandoffMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentHandoffMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentHandoff.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowID sets the "workflow_id" field.
func (m *AgentHandoffMutation) SetWorkflowID(s string) {
	m.workflow = &s
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *AgentHandoffMutation) WorkflowID() (r string, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldWorkflowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ClearWorkflowID clears the value of the "workflow_id" field.
func (m *AgentHandoffMutation) ClearWorkflowID() {
	m.workflow = nil
	m.clearedFields[agenthandoff.FieldWorkflowID] = struct{}{}
}

// WorkflowIDCleared returns if the "workflow_id" field was cleared in this mutation.
func (m *AgentHandoffMutation) WorkflowIDCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldWorkflowID]
	return ok
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *AgentHandoffMutation) ResetWorkflowID() {
	m.workflow = nil
	delete(m.clearedFields, agenthandoff.FieldWorkflowID)
}

// SetFromAgentID sets the "from_agent_id" field.
func (m *AgentHandoffMutation) SetFromAgentID(s string) {
	m.from_agent_id = &s
}

// FromAgentID returns the value of the "from_agent_id" field in the mutation.
func (m *AgentHandoffMutation) FromAgentID() (r string, exists bool) {
	v := m.from_agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAgentID returns the old "from_agent_id" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldFromAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAgentID: %w", err)
	}
	return oldValue.FromAgentID, nil
}

// ResetFromAgentID resets all changes to the "from_agent_id" field.
func (m *AgentHandoffMutation) ResetFromAgentID() {
	m.from_agent_id = nil
}

// SetFromAgentType sets the "from_agent_type" field.
func (m *AgentHandoffMutation) SetFromAgentType(s string) {
	m.from_agent_type = &s
}

// FromAgentType returns the value of the "from_agent_type" field in the mutation.
func (m *AgentHandoffMutation) FromAgentType() (r string, exists bool) {
	v := m.from_agent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAgentType returns the old "from_agent_type" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldFromAgentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAgentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAgentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAgentType: %w", err)
	}
	return oldValue.FromAgentType, nil
}

// ClearFromAgentType clears the value of the "from_agent_type" field.
func (m *AgentHandoffMutation) ClearFromAgentType() {
	m.from_agent_type = nil
	m.clearedFields[agenthandoff.FieldFromAgentType] = struct{}{}
}

// FromAgentTypeCleared returns if the "from_agent_type" field was cleared in this mutation.
func (m *AgentHandoffMutation) FromAgentTypeCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldFromAgentType]
	return ok
}

// ResetFromAgentType resets all changes to the "from_agent_type" field.
func (m *AgentHandoffMutation) ResetFromAgentType() {
	m.from_agent_type = nil
	delete(m.clearedFields, agenthandoff.FieldFromAgentType)
}

// SetToAgentID sets the "to_agent_id" field.
func (m *AgentHandoffMutation) SetToAgentID(s string) {
	m.to_agent_id = &s
}

// ToAgentID returns the value of the "to_agent_id" field in the mutation.
func (m *AgentHandoffMutation) ToAgentID() (r string, exists bool) {
	v := m.to_agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToAgentID returns the old "to_agent_id" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldToAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAgentID: %w", err)
	}
	return oldValue.ToAgentID, nil
}

// ResetToAgentID resets all changes to the "to_agent_id" field.
func (m *AgentHandoffMutation) ResetToAgentID() {
	m.to_agent_id = nil
}

// SetToAgentType sets the "to_agent_type" field.
func (m *AgentHandoffMutation) SetToAgentType(s string) {
	m.to_agent_type = &s
}

// ToAgentType returns the value of the "to_agent_type" field in the mutation.
func (m *AgentHandoffMutation) ToAgentType() (r string, exists bool) {
	v := m.to_agent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldToAgentType returns the old "to_agent_type" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldToAgentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAgentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAgentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAgentType: %w", err)
	}
	return oldValue.ToAgentType, nil
}

// ClearToAgentType clears the value of the "to_agent_type" field.
func (m *AgentHandoffMutation) ClearToAgentType() {
	m.to_agent_type = nil
	m.clearedFields[agenthandoff.FieldToAgentType] = struct{}{}
}

// ToAgentTypeCleared returns if the "to_agent_type" field was cleared in this mutation.
func (m *AgentHandoffMutation) ToAgentTypeCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldToAgentType]
	return ok
}

// ResetToAgentType resets all changes to the "to_agent_type" field.
func (m *AgentHandoffMutation) ResetToAgentType() {
	m.to_agent_type = nil
	delete(m.clearedFields, agenthandoff.FieldToAgentType)
}

// SetHandoffType sets the "handoff_type" field.
func (m *AgentHandoffMutation) SetHandoffType(s string) {
	m.handoff_type = &s
}

// HandoffType returns the value of the "handoff_type" field in the mutation.
func (m *AgentHandoffMutation) HandoffType() (r string, exists bool) {
	v := m.handoff_type
	if v == nil {
		return
	}
	return *v, true
}

// OldHandoffType returns the old "handoff_type" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldHandoffType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHandoffType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHandoffType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandoffType: %w", err)
	}
	return oldValue.HandoffType, nil
}

// ResetHandoffType resets all changes to the "handoff_type" field.
func (m *AgentHandoffMutation) ResetHandoffType() {
	m.handoff_type = nil
}

// SetStatus sets the "status" field.
func (m *AgentHandoffMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentHandoffMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentHandoffMutation) ResetStatus() {
	m.status = nil
}

// SetTraceID sets the "trace_id" field.
func (m *AgentHandoffMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *AgentHandoffMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *AgentHandoffMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[agenthandoff.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *AgentHandoffMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *AgentHandoffMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, agenthandoff.FieldTraceID)
}

// SetFromTaskID sets the "from_task_id" field.
func (m *AgentHandoffMutation) SetFromTaskID(s string) {
	m.from_task_id = &s
}

// FromTaskID returns the value of the "from_task_id" field in the mutation.
func (m *AgentHandoffMutation) FromTaskID() (r string, exists bool) {
	v := m.from_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromTaskID returns the old "from_task_id" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldFromTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromTaskID: %w", err)
	}
	return oldValue.FromTaskID, nil
}

// ClearFromTaskID clears the value of the "from_task_id" field.
func (m *AgentHandoffMutation) ClearFromTaskID() {
	m.from_task_id = nil
	m.clearedFields[agenthandoff.FieldFromTaskID] = struct{}{}
}

// FromTaskIDCleared returns if the "from_task_id" field was cleared in this mutation.
func (m *AgentHandoffMutation) FromTaskIDCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldFromTaskID]
	return ok
}

// ResetFromTaskID resets all changes to the "from_task_id" field.
func (m *AgentHandoffMutation) ResetFromTaskID() {
	m.from_task_id = nil
	delete(m.clearedFields, agenthandoff.FieldFromTaskID)
}

// SetToTaskID sets the "to_task_id" field.
func (m *AgentHandoffMutation) SetToTaskID(s string) {
	m.to_task_id = &s
}

// ToTaskID returns the value of the "to_task_id" field in the mutation.
func (m *AgentHandoffMutation) ToTaskID() (r string, exists bool) {
	v := m.to_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToTaskID returns the old "to_task_id" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldToTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToTaskID: %w", err)
	}
	return oldValue.ToTaskID, nil
}

// ClearToTaskID clears the value of the "to_task_id" field.
func (m *AgentHandoffMutation) ClearToTaskID() {
	m.to_task_id = nil
	m.clearedFields[agenthandoff.FieldToTaskID] = struct{}{}
}

// ToTaskIDCleared returns if the "to_task_id" field was cleared in this mutation.
func (m *AgentHandoffMutation) ToTaskIDCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldToTaskID]
	return ok
}

// ResetToTaskID resets all changes to the "to_task_id" field.
func (m *AgentHandoffMutation) ResetToTaskID() {
	m.to_task_id = nil
	delete(m.clearedFields, agenthandoff.FieldToTaskID)
}

// SetPayload sets the "payload" field.
func (m *AgentHandoffMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *AgentHandoffMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *AgentHandoffMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[agenthandoff.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *AgentHandoffMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *AgentHandoffMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, agenthandoff.FieldPayload)
}

// SetMetadata sets the "metadata" field.
func (m *AgentHandoffMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AgentHandoffMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AgentHandoffMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[agenthandoff.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AgentHandoffMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AgentHandoffMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, agenthandoff.FieldMetadata)
}

// SetPayloadSizeBytes sets the "payload_size_bytes" field.
func (m *AgentHandoffMutation) SetPayloadSizeBytes(i int) {
	m.payload_size_bytes = &i
	m.addpayload_size_bytes = nil
}

// PayloadSizeBytes returns the value of the "payload_size_bytes" field in the mutation.
func (m *AgentHandoffMutation) PayloadSizeBytes() (r int, exists bool) {
	v := m.payload_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldPayloadSizeBytes returns the old "payload_size_bytes" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldPayloadSizeBytes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayloadSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayloadSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayloadSizeBytes: %w", err)
	}
	return oldValue.PayloadSizeBytes, nil
}

// AddPayloadSizeBytes adds i to the "payload_size_bytes" field.
func (m *AgentHandoffMutation) AddPayloadSizeBytes(i int) {
	if m.addpayload_size_bytes != nil {
		*m.addpayload_size_bytes += i
	} else {
		m.addpayload_size_bytes = &i
	}
}

// AddedPayloadSizeBytes returns the value that was added to the "payload_size_bytes" field in this mutation.
func (m *AgentHandoffMutation) AddedPayloadSizeBytes() (r int, exists bool) {
	v := m.addpayload_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayloadSizeBytes resets all changes to the "payload_size_bytes" field.
func (m *AgentHandoffMutation) ResetPayloadSizeBytes() {
	m.payload_size_bytes = nil
	m.addpayload_size_bytes = nil
}

// SetLatencyMs sets the "latency_ms" field.
func (m *AgentHandoffMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *AgentHandoffMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *AgentHandoffMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *AgentHandoffMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatencyMs clears the value of the "latency_ms" field.
func (m *AgentHandoffMutation) ClearLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
	m.clearedFields[agenthandoff.FieldLatencyMs] = struct{}{}
}

// LatencyMsCleared returns if the "latency_ms" field was cleared in this mutation.
func (m *AgentHandoffMutation) LatencyMsCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldLatencyMs]
	return ok
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *AgentHandoffMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
	delete(m.clearedFields, agenthandoff.FieldLatencyMs)
}

// SetErrorMessage sets the "error_message" field.
func (m *AgentHandoffMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AgentHandoffMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AgentHandoffMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[agenthandoff.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AgentHandoffMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AgentHandoffMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, agenthandoff.FieldErrorMessage)
}

// SetInitiatedAt sets the "initiated_at" field.
func (m *AgentHandoffMutation) SetInitiatedAt(t time.Time) {
	m.initiated_at = &t
}

// InitiatedAt returns the value of the "initiated_at" field in the mutation.
func (m *AgentHandoffMutation) InitiatedAt() (r time.Time, exists bool) {
	v := m.initiated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiatedAt returns the old "initiated_at" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldInitiatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiatedAt: %w", err)
	}
	return oldValue.InitiatedAt, nil
}

// ResetInitiatedAt resets all changes to the "initiated_at" field.
func (m *AgentHandoffMutation) ResetInitiatedAt() {
	m.initiated_at = nil
}

// SetAcceptedAt sets the "accepted_at" field.
func (m *AgentHandoffMutation) SetAcceptedAt(t time.Time) {
	m.accepted_at = &t
}

// AcceptedAt returns the value of the "accepted_at" field in the mutation.
func (m *AgentHandoffMutation) AcceptedAt() (r time.Time, exists bool) {
	v := m.accepted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAt returns the old "accepted_at" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldAcceptedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAt: %w", err)
	}
	return oldValue.AcceptedAt, nil
}

// ClearAcceptedAt clears the value of the "accepted_at" field.
func (m *AgentHandoffMutation) ClearAcceptedAt() {
	m.accepted_at = nil
	m.clearedFields[agenthandoff.FieldAcceptedAt] = struct{}{}
}

// AcceptedAtCleared returns if the "accepted_at" field was cleared in this mutation.
func (m *AgentHandoffMutation) AcceptedAtCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldAcceptedAt]
	return ok
}

// ResetAcceptedAt resets all changes to the "accepted_at" field.
func (m *AgentHandoffMutation) ResetAcceptedAt() {
	m.accepted_at = nil
	delete(m.clearedFields, agenthandoff.FieldAcceptedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *AgentHandoffMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *AgentHandoffMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *AgentHandoffMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[agenthandoff.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *AgentHandoffMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[agenthandoff.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *AgentHandoffMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, agenthandoff.FieldCompletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentHandoffMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentHandoffMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentHandoffMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentHandoffMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentHandoffMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AgentHandoff entity.
// If the AgentHandoff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentHandoffMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentHandoffMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *AgentHandoffMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[agenthandoff.FieldWorkflowID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *AgentHandoffMutation) WorkflowCleared() bool {
	return m.WorkflowIDCleared() || m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *AgentHandoffMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *AgentHandoffMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the AgentHandoffMutation builder.
func (m *AgentHandoffMutation) Where(ps ...predicate.AgentHandoff) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentHandoffMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentHandoffMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentHandoff, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentHandoffMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentHandoffMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentHandoff).
func (m *AgentHandoffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentHandoffMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.workflow != nil {
		fields = append(fields, agenthandoff.FieldWorkflowID)
	}
	if m.from_agent_id != nil {
		fields = append(fields, agenthandoff.FieldFromAgentID)
	}
	if m.from_agent_type != nil {
		fields = append(fields, agenthandoff.FieldFromAgentType)
	}
	if m.to_agent_id != nil {
		fields = append(fields, agenthandoff.FieldToAgentID)
	}
	if m.to_agent_type != nil {
		fields = append(fields, agenthandoff.FieldToAgentType)
	}
	if m.handoff_type != nil {
		fields = append(fields, agenthandoff.FieldHandoffType)
	}
	if m.status != nil {
		fields = append(fields, agenthandoff.FieldStatus)
	}
	if m.trace_id != nil {
		fields = append(fields, agenthandoff.FieldTraceID)
	}
	if m.from_task_id != nil {
		fields = append(fields, agenthandoff.FieldFromTaskID)
	}
	if m.to_task_id != nil {
		fields = append(fields, agenthandoff.FieldToTaskID)
	}
	if m.payload != nil {
		fields = append(fields, agenthandoff.FieldPayload)
	}
	if m.metadata != nil {
		fields = append(fields, agenthandoff.FieldMetadata)
	}
	if m.payload_size_bytes != nil {
		fields = append(fields, agenthandoff.FieldPayloadSizeBytes)
	}
	if m.latency_ms != nil {
		fields = append(fields, agenthandoff.FieldLatencyMs)
	}
	if m.error_message != nil {
		fields = append(fields, agenthandoff.FieldErrorMessage)
	}
	if m.initiated_at != nil {
		fields = append(fields, agenthandoff.FieldInitiatedAt)
	}
	if m.accepted_at != nil {
		fields = append(fields, agenthandoff.FieldAcceptedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, agenthandoff.FieldCompletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, agenthandoff.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agenthandoff.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentHandoffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agenthandoff.FieldWorkflowID:
		return m.WorkflowID()
	case agenthandoff.FieldFromAgentID:
		return m.FromAgentID()
	case agenthandoff.FieldFromAgentType:
		return m.FromAgentType()
	case agenthandoff.FieldToAgentID:
		return m.ToAgentID()
	case agenthandoff.FieldToAgentType:
		return m.ToAgentType()
	case agenthandoff.FieldHandoffType:
		return m.HandoffType()
	case agenthandoff.FieldStatus:
		return m.Status()
	case agenthandoff.FieldTraceID:
		return m.TraceID()
	case agenthandoff.FieldFromTaskID:
		return m.FromTaskID()
	case agenthandoff.FieldToTaskID:
		return m.ToTaskID()
	case agenthandoff.FieldPayload:
		return m.Payload()
	case agenthandoff.FieldMetadata:
		return m.Metadata()
	case agenthandoff.FieldPayloadSizeBytes:
		return m.PayloadSizeBytes()
	case agenthandoff.FieldLatencyMs:
		return m.LatencyMs()
	case agenthandoff.FieldErrorMessage:
		return m.ErrorMessage()
	case agenthandoff.FieldInitiatedAt:
		return m.InitiatedAt()
	case agenthandoff.FieldAcceptedAt:
		return m.AcceptedAt()
	case agenthandoff.FieldCompletedAt:
		return m.CompletedAt()
	case agenthandoff.FieldCreatedAt:
		return m.CreatedAt()
	case agenthandoff.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentHandoffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agenthandoff.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case agenthandoff.FieldFromAgentID:
		return m.OldFromAgentID(ctx)
	case agenthandoff.FieldFromAgentType:
		return m.OldFromAgentType(ctx)
	case agenthandoff.FieldToAgentID:
		return m.OldToAgentID(ctx)
	case agenthandoff.FieldToAgentType:
		return m.OldToAgentType(ctx)
	case agenthandoff.FieldHandoffType:
		return m.OldHandoffType(ctx)
	case agenthandoff.FieldStatus:
		return m.OldStatus(ctx)
	case agenthandoff.FieldTraceID:
		return m.OldTraceID(ctx)
	case agenthandoff.FieldFromTaskID:
		return m.OldFromTaskID(ctx)
	case agenthandoff.FieldToTaskID:
		return m.OldToTaskID(ctx)
	case agenthandoff.FieldPayload:
		return m.OldPayload(ctx)
	case agenthandoff.FieldMetadata:
		return m.OldMetadata(ctx)
	case agenthandoff.FieldPayloadSizeBytes:
		return m.OldPayloadSizeBytes(ctx)
	case agenthandoff.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case agenthandoff.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case agenthandoff.FieldInitiatedAt:
		return m.OldInitiatedAt(ctx)
	case agenthandoff.FieldAcceptedAt:
		return m.OldAcceptedAt(ctx)
	case agenthandoff.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case agenthandoff.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agenthandoff.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AgentHandoff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentHandoffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agenthandoff.FieldWorkflowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case agenthandoff.FieldFromAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAgentID(v)
		return nil
	case agenthandoff.FieldFromAgentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAgentType(v)
		return nil
	case agenthandoff.FieldToAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAgentID(v)
		return nil
	case agenthandoff.FieldToAgentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAgentType(v)
		return nil
	case agenthandoff.FieldHandoffType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandoffType(v)
		return nil
	case agenthandoff.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agenthandoff.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case agenthandoff.FieldFromTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromTaskID(v)
		return nil
	case agenthandoff.FieldToTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToTaskID(v)
		return nil
	case agenthandoff.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case agenthandoff.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case agenthandoff.FieldPayloadSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayloadSizeBytes(v)
		return nil
	case agenthandoff.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case agenthandoff.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case agenthandoff.FieldInitiatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiatedAt(v)
		return nil
	case agenthandoff.FieldAcceptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAt(v)
		return nil
	case agenthandoff.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case agenthandoff.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agenthandoff.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AgentHandoff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentHandoffMutation) AddedFields() []string {
	var fields []string
	if m.addpayload_size_bytes != nil {
		fields = append(fields, agenthandoff.FieldPayloadSizeBytes)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, agenthandoff.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentHandoffMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agenthandoff.FieldPayloadSizeBytes:
		return m.AddedPayloadSizeBytes()
	case agenthandoff.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentHandoffMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agenthandoff.FieldPayloadSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayloadSizeBytes(v)
		return nil
	case agenthandoff.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown AgentHandoff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentHandoffMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agenthandoff.FieldWorkflowID) {
		fields = append(fields, agenthandoff.FieldWorkflowID)
	}
	if m.FieldCleared(agenthandoff.FieldFromAgentType) {
		fields = append(fields, agenthandoff.FieldFromAgentType)
	}
	if m.FieldCleared(agenthandoff.FieldToAgentType) {
		fields = append(fields, agenthandoff.FieldToAgentType)
	}
	if m.FieldCleared(agenthandoff.FieldTraceID) {
		fields = append(fields, agenthandoff.FieldTraceID)
	}
	if m.FieldCleared(agenthandoff.FieldFromTaskID) {
		fields = append(fields, agenthandoff.FieldFromTaskID)
	}
	if m.FieldCleared(agenthandoff.FieldToTaskID) {
		fields = append(fields, agenthandoff.FieldToTaskID)
	}
	if m.FieldCleared(agenthandoff.FieldPayload) {
		fields = append(fields, agenthandoff.FieldPayload)
	}
	if m.FieldCleared(agenthandoff.FieldMetadata) {
		fields = append(fields, agenthandoff.FieldMetadata)
	}
	if m.FieldCleared(agenthandoff.FieldLatencyMs) {
		fields = append(fields, agenthandoff.FieldLatencyMs)
	}
	if m.FieldCleared(agenthandoff.FieldErrorMessage) {
		fields = append(fields, agenthandoff.FieldErrorMessage)
	}
	if m.FieldCleared(agenthandoff.FieldAcceptedAt) {
		fields = append(fields, agenthandoff.FieldAcceptedAt)
	}
	if m.FieldCleared(agenthandoff.FieldCompletedAt) {
		fields = append(fields, agenthandoff.FieldCompletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentHandoffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentHandoffMutation) ClearField(name string) error {
	switch name {
	case agenthandoff.FieldWorkflowID:
		m.ClearWorkflowID()
		return nil
	case agenthandoff.FieldFromAgentType:
		m.ClearFromAgentType()
		return nil
	case agenthandoff.FieldToAgentType:
		m.ClearToAgentType()
		return nil
	case agenthandoff.FieldTraceID:
		m.ClearTraceID()
		return nil
	case agenthandoff.FieldFromTaskID:
		m.ClearFromTaskID()
		return nil
	case agenthandoff.FieldToTaskID:
		m.ClearToTaskID()
		return nil
	case agenthandoff.FieldPayload:
		m.ClearPayload()
		return nil
	case agenthandoff.FieldMetadata:
		m.ClearMetadata()
		return nil
	case agenthandoff.FieldLatencyMs:
		m.ClearLatencyMs()
		return nil
	case agenthandoff.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case agenthandoff.FieldAcceptedAt:
		m.ClearAcceptedAt()
		return nil
	case agenthandoff.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	}
	return fmt.Errorf("unknown AgentHandoff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentHandoffMutation) ResetField(name string) error {
	switch name {
	case agenthandoff.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case agenthandoff.FieldFromAgentID:
		m.ResetFromAgentID()
		return nil
	case agenthandoff.FieldFromAgentType:
		m.ResetFromAgentType()
		return nil
	case agenthandoff.FieldToAgentID:
		m.ResetToAgentID()
		return nil
	case agenthandoff.FieldToAgentType:
		m.ResetToAgentType()
		return nil
	case agenthandoff.FieldHandoffType:
		m.ResetHandoffType()
		return nil
	case agenthandoff.FieldStatus:
		m.ResetStatus()
		return nil
	case agenthandoff.FieldTraceID:
		m.ResetTraceID()
		return nil
	case agenthandoff.FieldFromTaskID:
		m.ResetFromTaskID()
		return nil
	case agenthandoff.FieldToTaskID:
		m.ResetToTaskID()
		return nil
	case agenthandoff.FieldPayload:
		m.ResetPayload()
		return nil
	case agenthandoff.FieldMetadata:
		m.ResetMetadata()
		return nil
	case agenthandoff.FieldPayloadSizeBytes:
		m.ResetPayloadSizeBytes()
		return nil
	case agenthandoff.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case agenthandoff.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case agenthandoff.FieldInitiatedAt:
		m.ResetInitiatedAt()
		return nil
	case agenthandoff.FieldAcceptedAt:
		m.ResetAcceptedAt()
		return nil
	case agenthandoff.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case agenthandoff.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agenthandoff.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AgentHandoff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentHandoffMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflow != nil {
		edges = append(edges, agenthandoff.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentHandoffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agenthandoff.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentHandoffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentHandoffMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentHandoffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflow {
		edges = append(edges, agenthandoff.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentHandoffMutation) EdgeCleared(name string) bool {
	switch name {
	case agenthandoff.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentHandoffMutation) ClearEdge(name string) error {
	switch name {
	case agenthandoff.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown AgentHandoff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentHandoffMutation) ResetEdge(name string) error {
	switch name {
	case agenthandoff.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown AgentHandoff edge %s", name)
}

// AgentTaskMutation represents an operation that mutates the AgentTask nodes in the graph.
type AgentTaskMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	agent_id                *string
	agent_type              *string
	task_type               *string
	name                    *string
	status                  *string
	trace_id                *string
	span_id                 *string
	parent_span_id          *string
	input                   *map[string]interface{}
	output                  *map[string]interface{}
	metadata                *map[string]interface{}
	llm_call_count          *int
	addllm_call_count       *int
	tool_call_count         *int
	addtool_call_count      *int
	retry_count             *int
	addretry_count          *int
	tokens_prompt           *int
	addtokens_prompt        *int
	tokens_completion       *int
	addtokens_completion    *int
	tokens_total            *int
	addtokens_total         *int
	cost_usd                *float64
	addcost_usd             *float64
	duration_ms             *int64
	addduration_ms          *int64
	error_type              *string
	error_message           *string
	started_at              *time.Time
	ended_at                *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	workflow                *string
	clearedworkflow         bool
	tool_invocations        map[string]struct{}
	removedtool_invocations map[string]struct{}
	clearedtool_invocations bool
	events                  map[string]struct{}
	removedevents           map[string]struct{}
	clearedevents           bool
	done                    bool
	oldValue                func(context.Context) (*AgentTask, error)
	predicates              []predicate.AgentTask
}

var _ ent.Mutation = (*AgentTaskMutation)(nil)

// agenttaskOption allows management of the mutation configuration using functional options.
type agenttaskOption func(*AgentTaskMutation)

// newAgentTaskMutation creates new mutation for the AgentTask entity.
func newAgentTaskMutation(c config, op Op, opts ...agenttaskOption) *AgentTaskMutation {
	m := &AgentTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentTaskID sets the ID field of the mutation.
func withAgentTaskID(id string) agenttaskOption {
	return func(m *AgentTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentTask
		)
		m.oldValue = func(ctx context.Context) (*AgentTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentTask sets the old AgentTask of the mutation.
func withAgentTask(node *AgentTask) agenttaskOption {
	return func(m *AgentTaskMutation) {
		m.oldValue = func(context.Context) (*AgentTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentTask entities.
func (m *AgentTaskMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentTaskMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentTaskMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowID sets the "workflow_id" field.
func (m *AgentTaskMutation) SetWorkflowID(s string) {
	m.workflow = &s
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *AgentTaskMutation) WorkflowID() (r string, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldWorkflowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ClearWorkflowID clears the value of the "workflow_id" field.
func (m *AgentTaskMutation) ClearWorkflowID() {
	m.workflow = nil
	m.clearedFields[agenttask.FieldWorkflowID] = struct{}{}
}

// WorkflowIDCleared returns if the "workflow_id" field was cleared in this mutation.
func (m *AgentTaskMutation) WorkflowIDCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldWorkflowID]
	return ok
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *AgentTaskMutation) ResetWorkflowID() {
	m.workflow = nil
	delete(m.clearedFields, agenttask.FieldWorkflowID)
}

// SetAgentID sets the "agent_id" field.
func (m *AgentTaskMutation) SetAgentID(s string) {
	m.agent_id = &s
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *AgentTaskMutation) AgentID() (r string, exists bool) {
	v := m.agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *AgentTaskMutation) ResetAgentID() {
	m.agent_id = nil
}

// SetAgentType sets the "agent_type" field.
func (m *AgentTaskMutation) SetAgentType(s string) {
	m.agent_type = &s
}

// AgentType returns the value of the "agent_type" field in the mutation.
func (m *AgentTaskMutation) AgentType() (r string, exists bool) {
	v := m.agent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentType returns the old "agent_type" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldAgentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentType: %w", err)
	}
	return oldValue.AgentType, nil
}

// ClearAgentType clears the value of the "agent_type" field.
func (m *AgentTaskMutation) ClearAgentType() {
	m.agent_type = nil
	m.clearedFields[agenttask.FieldAgentType] = struct{}{}
}

// AgentTypeCleared returns if the "agent_type" field was cleared in this mutation.
func (m *AgentTaskMutation) AgentTypeCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldAgentType]
	return ok
}

// ResetAgentType resets all changes to the "agent_type" field.
func (m *AgentTaskMutation) ResetAgentType() {
	m.agent_type = nil
	delete(m.clearedFields, agenttask.FieldAgentType)
}

// SetTaskType sets the "task_type" field.
func (m *AgentTaskMutation) SetTaskType(s string) {
	m.task_type = &s
}

// TaskType returns the value of the "task_type" field in the mutation.
func (m *AgentTaskMutation) TaskType() (r string, exists bool) {
	v := m.task_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskType returns the old "task_type" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldTaskType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskType: %w", err)
	}
	return oldValue.TaskType, nil
}

// ResetTaskType resets all changes to the "task_type" field.
func (m *AgentTaskMutation) ResetTaskType() {
	m.task_type = nil
}

// SetName sets the "name" field.
func (m *AgentTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AgentTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AgentTaskMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *AgentTaskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentTaskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentTaskMutation) ResetStatus() {
	m.status = nil
}

// SetTraceID sets the "trace_id" field.
func (m *AgentTaskMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *AgentTaskMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *AgentTaskMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[agenttask.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *AgentTaskMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *AgentTaskMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, agenttask.FieldTraceID)
}

// SetSpanID sets the "span_id" field.
func (m *AgentTaskMutation) SetSpanID(s string) {
	m.span_id = &s
}

// SpanID returns the value of the "span_id" field in the mutation.
func (m *AgentTaskMutation) SpanID() (r string, exists bool) {
	v := m.span_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpanID returns the old "span_id" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldSpanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpanID: %w", err)
	}
	return oldValue.SpanID, nil
}

// ClearSpanID clears the value of the "span_id" field.
func (m *AgentTaskMutation) ClearSpanID() {
	m.span_id = nil
	m.clearedFields[agenttask.FieldSpanID] = struct{}{}
}

// SpanIDCleared returns if the "span_id" field was cleared in this mutation.
func (m *AgentTaskMutation) SpanIDCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldSpanID]
	return ok
}

// ResetSpanID resets all changes to the "span_id" field.
func (m *AgentTaskMutation) ResetSpanID() {
	m.span_id = nil
	delete(m.clearedFields, agenttask.FieldSpanID)
}

// SetParentSpanID sets the "parent_span_id" field.
func (m *AgentTaskMutation) SetParentSpanID(s string) {
	m.parent_span_id = &s
}

// ParentSpanID returns the value of the "parent_span_id" field in the mutation.
func (m *AgentTaskMutation) ParentSpanID() (r string, exists bool) {
	v := m.parent_span_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentSpanID returns the old "parent_span_id" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldParentSpanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentSpanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentSpanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentSpanID: %w", err)
	}
	return oldValue.ParentSpanID, nil
}

// ClearParentSpanID clears the value of the "parent_span_id" field.
func (m *AgentTaskMutation) ClearParentSpanID() {
	m.parent_span_id = nil
	m.clearedFields[agenttask.FieldParentSpanID] = struct{}{}
}

// ParentSpanIDCleared returns if the "parent_span_id" field was cleared in this mutation.
func (m *AgentTaskMutation) ParentSpanIDCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldParentSpanID]
	return ok
}

// ResetParentSpanID resets all changes to the "parent_span_id" field.
func (m *AgentTaskMutation) ResetParentSpanID() {
	m.parent_span_id = nil
	delete(m.clearedFields, agenttask.FieldParentSpanID)
}

// SetInput sets the "input" field.
func (m *AgentTaskMutation) SetInput(value map[string]interface{}) {
	m.input = &value
}

// Input returns the value of the "input" field in the mutation.
func (m *AgentTaskMutation) Input() (r map[string]interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldInput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ClearInput clears the value of the "input" field.
func (m *AgentTaskMutation) ClearInput() {
	m.input = nil
	m.clearedFields[agenttask.FieldInput] = struct{}{}
}

// InputCleared returns if the "input" field was cleared in this mutation.
func (m *AgentTaskMutation) InputCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldInput]
	return ok
}

// ResetInput resets all changes to the "input" field.
func (m *AgentTaskMutation) ResetInput() {
	m.input = nil
	delete(m.clearedFields, agenttask.FieldInput)
}

// SetOutput sets the "output" field.
func (m *AgentTaskMutation) SetOutput(value map[string]interface{}) {
	m.output = &value
}

// Output returns the value of the "output" field in the mutation.
func (m *AgentTaskMutation) Output() (r map[string]interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldOutput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *AgentTaskMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[agenttask.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *AgentTaskMutation) OutputCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *AgentTaskMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, agenttask.FieldOutput)
}

// SetMetadata sets the "metadata" field.
func (m *AgentTaskMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AgentTaskMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AgentTaskMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[agenttask.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AgentTaskMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AgentTaskMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, agenttask.FieldMetadata)
}

// SetLlmCallCount sets the "llm_call_count" field.
func (m *AgentTaskMutation) SetLlmCallCount(i int) {
	m.llm_call_count = &i
	m.addllm_call_count = nil
}

// LlmCallCount returns the value of the "llm_call_count" field in the mutation.
func (m *AgentTaskMutation) LlmCallCount() (r int, exists bool) {
	v := m.llm_call_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLlmCallCount returns the old "llm_call_count" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldLlmCallCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLlmCallCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLlmCallCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLlmCallCount: %w", err)
	}
	return oldValue.LlmCallCount, nil
}

// AddLlmCallCount adds i to the "llm_call_count" field.
func (m *AgentTaskMutation) AddLlmCallCount(i int) {
	if m.addllm_call_count != nil {
		*m.addllm_call_count += i
	} else {
		m.addllm_call_count = &i
	}
}

// AddedLlmCallCount returns the value that was added to the "llm_call_count" field in this mutation.
func (m *AgentTaskMutation) AddedLlmCallCount() (r int, exists bool) {
	v := m.addllm_call_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLlmCallCount resets all changes to the "llm_call_count" field.
func (m *AgentTaskMutation) ResetLlmCallCount() {
	m.llm_call_count = nil
	m.addllm_call_count = nil
}

// SetToolCallCount sets the "tool_call_count" field.
func (m *AgentTaskMutation) SetToolCallCount(i int) {
	m.tool_call_count = &i
	m.addtool_call_count = nil
}

// ToolCallCount returns the value of the "tool_call_count" field in the mutation.
func (m *AgentTaskMutation) ToolCallCount() (r int, exists bool) {
	v := m.tool_call_count
	if v == nil {
		return
	}
	return *v, true
}

// OldToolCallCount returns the old "tool_call_count" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldToolCallCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolCallCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolCallCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolCallCount: %w", err)
	}
	return oldValue.ToolCallCount, nil
}

// AddToolCallCount adds i to the "tool_call_count" field.
func (m *AgentTaskMutation) AddToolCallCount(i int) {
	if m.addtool_call_count != nil {
		*m.addtool_call_count += i
	} else {
		m.addtool_call_count = &i
	}
}

// AddedToolCallCount returns the value that was added to the "tool_call_count" field in this mutation.
func (m *AgentTaskMutation) AddedToolCallCount() (r int, exists bool) {
	v := m.addtool_call_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetToolCallCount resets all changes to the "tool_call_count" field.
func (m *AgentTaskMutation) ResetToolCallCount() {
	m.tool_call_count = nil
	m.addtool_call_count = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *AgentTaskMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *AgentTaskMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *AgentTaskMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *AgentTaskMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *AgentTaskMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetTokensPrompt sets the "tokens_prompt" field.
func (m *AgentTaskMutation) SetTokensPrompt(i int) {
	m.tokens_prompt = &i
	m.addtokens_prompt = nil
}

// TokensPrompt returns the value of the "tokens_prompt" field in the mutation.
func (m *AgentTaskMutation) TokensPrompt() (r int, exists bool) {
	v := m.tokens_prompt
	if v == nil {
		return
	}
	return *v, true
}

// OldTokensPrompt returns the old "tokens_prompt" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldTokensPrompt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokensPrompt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokensPrompt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokensPrompt: %w", err)
	}
	return oldValue.TokensPrompt, nil
}

// AddTokensPrompt adds i to the "tokens_prompt" field.
func (m *AgentTaskMutation) AddTokensPrompt(i int) {
	if m.addtokens_prompt != nil {
		*m.addtokens_prompt += i
	} else {
		m.addtokens_prompt = &i
	}
}

// AddedTokensPrompt returns the value that was added to the "tokens_prompt" field in this mutation.
func (m *AgentTaskMutation) AddedTokensPrompt() (r int, exists bool) {
	v := m.addtokens_prompt
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokensPrompt resets all changes to the "tokens_prompt" field.
func (m *AgentTaskMutation) ResetTokensPrompt() {
	m.tokens_prompt = nil
	m.addtokens_prompt = nil
}

// SetTokensCompletion sets the "tokens_completion" field.
func (m *AgentTaskMutation) SetTokensCompletion(i int) {
	m.tokens_completion = &i
	m.addtokens_completion = nil
}

// TokensCompletion returns the value of the "tokens_completion" field in the mutation.
func (m *AgentTaskMutation) TokensCompletion() (r int, exists bool) {
	v := m.tokens_completion
	if v == nil {
		return
	}
	return *v, true
}

// OldTokensCompletion returns the old "tokens_completion" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldTokensCompletion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokensCompletion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokensCompletion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokensCompletion: %w", err)
	}
	return oldValue.TokensCompletion, nil
}

// AddTokensCompletion adds i to the "tokens_completion" field.
func (m *AgentTaskMutation) AddTokensCompletion(i int) {
	if m.addtokens_completion != nil {
		*m.addtokens_completion += i
	} else {
		m.addtokens_completion = &i
	}
}

// AddedTokensCompletion returns the value that was added to the "tokens_completion" field in this mutation.
func (m *AgentTaskMutation) AddedTokensCompletion() (r int, exists bool) {
	v := m.addtokens_completion
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokensCompletion resets all changes to the "tokens_completion" field.
func (m *AgentTaskMutation) ResetTokensCompletion() {
	m.tokens_completion = nil
	m.addtokens_completion = nil
}

// SetTokensTotal sets the "tokens_total" field.
func (m *AgentTaskMutation) SetTokensTotal(i int) {
	m.tokens_total = &i
	m.addtokens_total = nil
}

// TokensTotal returns the value of the "tokens_total" field in the mutation.
func (m *AgentTaskMutation) TokensTotal() (r int, exists bool) {
	v := m.tokens_total
	if v == nil {
		return
	}
	return *v, true
}

// OldTokensTotal returns the old "tokens_total" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldTokensTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokensTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokensTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokensTotal: %w", err)
	}
	return oldValue.TokensTotal, nil
}

// AddTokensTotal adds i to the "tokens_total" field.
func (m *AgentTaskMutation) AddTokensTotal(i int) {
	if m.addtokens_total != nil {
		*m.addtokens_total += i
	} else {
		m.addtokens_total = &i
	}
}

// AddedTokensTotal returns the value that was added to the "tokens_total" field in this mutation.
func (m *AgentTaskMutation) AddedTokensTotal() (r int, exists bool) {
	v := m.addtokens_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokensTotal resets all changes to the "tokens_total" field.
func (m *AgentTaskMutation) ResetTokensTotal() {
	m.tokens_total = nil
	m.addtokens_total = nil
}

// SetCostUsd sets the "cost_usd" field.
func (m *AgentTaskMutation) SetCostUsd(f float64) {
	m.cost_usd = &f
	m.addcost_usd = nil
}

// CostUsd returns the value of the "cost_usd" field in the mutation.
func (m *AgentTaskMutation) CostUsd() (r float64, exists bool) {
	v := m.cost_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldCostUsd returns the old "cost_usd" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldCostUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostUsd: %w", err)
	}
	return oldValue.CostUsd, nil
}

// AddCostUsd adds f to the "cost_usd" field.
func (m *AgentTaskMutation) AddCostUsd(f float64) {
	if m.addcost_usd != nil {
		*m.addcost_usd += f
	} else {
		m.addcost_usd = &f
	}
}

// AddedCostUsd returns the value that was added to the "cost_usd" field in this mutation.
func (m *AgentTaskMutation) AddedCostUsd() (r float64, exists bool) {
	v := m.addcost_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetCostUsd resets all changes to the "cost_usd" field.
func (m *AgentTaskMutation) ResetCostUsd() {
	m.cost_usd = nil
	m.addcost_usd = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *AgentTaskMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *AgentTaskMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *AgentTaskMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *AgentTaskMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *AgentTaskMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[agenttask.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *AgentTaskMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *AgentTaskMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, agenttask.FieldDurationMs)
}

// SetErrorType sets the "error_type" field.
func (m *AgentTaskMutation) SetErrorType(s string) {
	m.error_type = &s
}

// ErrorType returns the value of the "error_type" field in the mutation.
func (m *AgentTaskMutation) ErrorType() (r string, exists bool) {
	v := m.error_type
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorType returns the old "error_type" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldErrorType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorType: %w", err)
	}
	return oldValue.ErrorType, nil
}

// ClearErrorType clears the value of the "error_type" field.
func (m *AgentTaskMutation) ClearErrorType() {
	m.error_type = nil
	m.clearedFields[agenttask.FieldErrorType] = struct{}{}
}

// ErrorTypeCleared returns if the "error_type" field was cleared in this mutation.
func (m *AgentTaskMutation) ErrorTypeCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldErrorType]
	return ok
}

// ResetErrorType resets all changes to the "error_type" field.
func (m *AgentTaskMutation) ResetErrorType() {
	m.error_type = nil
	delete(m.clearedFields, agenttask.FieldErrorType)
}

// SetErrorMessage sets the "error_message" field.
func (m *AgentTaskMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AgentTaskMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AgentTaskMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[agenttask.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AgentTaskMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AgentTaskMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, agenttask.FieldErrorMessage)
}

// SetStartedAt sets the "started_at" field.
func (m *AgentTaskMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *AgentTaskMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *AgentTaskMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *AgentTaskMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *AgentTaskMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *AgentTaskMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[agenttask.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *AgentTaskMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[agenttask.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *AgentTaskMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, agenttask.FieldEndedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *AgentTaskMutation) ClearWorkflow() {
	m.clearedworkflow = true
	m.clearedFields[agenttask.FieldWorkflowID] = struct{}{}
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *AgentTaskMutation) WorkflowCleared() bool {
	return m.WorkflowIDCleared() || m.clearedworkflow
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *AgentTaskMutation) WorkflowIDs() (ids []string) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *AgentTaskMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddToolInvocationIDs adds the "tool_invocations" edge to the ToolInvocation entity by ids.
func (m *AgentTaskMutation) AddToolInvocationIDs(ids ...string) {
	if m.tool_invocations == nil {
		m.tool_invocations = make(map[string]struct{})
	}
	for i := range ids {
		m.tool_invocations[ids[i]] = struct{}{}
	}
}

// ClearToolInvocations clears the "tool_invocations" edge to the ToolInvocation entity.
func (m *AgentTaskMutation) ClearToolInvocations() {
	m.clearedtool_invocations = true
}

// ToolInvocationsCleared reports if the "tool_invocations" edge to the ToolInvocation entity was cleared.
func (m *AgentTaskMutation) ToolInvocationsCleared() bool {
	return m.clearedtool_invocations
}

// RemoveToolInvocationIDs removes the "tool_invocations" edge to the ToolInvocation entity by IDs.
func (m *AgentTaskMutation) RemoveToolInvocationIDs(ids ...string) {
	if m.removedtool_invocations == nil {
		m.removedtool_invocations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tool_invocations, ids[i])
		m.removedtool_invocations[ids[i]] = struct{}{}
	}
}

// RemovedToolInvocations returns the removed IDs of the "tool_invocations" edge to the ToolInvocation entity.
func (m *AgentTaskMutation) RemovedToolInvocationsIDs() (ids []string) {
	for id := range m.removedtool_invocations {
		ids = append(ids, id)
	}
	return
}

// ToolInvocationsIDs returns the "tool_invocations" edge IDs in the mutation.
func (m *AgentTaskMutation) ToolInvocationsIDs() (ids []string) {
	for id := range m.tool_invocations {
		ids = append(ids, id)
	}
	return
}

// ResetToolInvocations resets all changes to the "tool_invocations" edge.
func (m *AgentTaskMutation) ResetToolInvocations() {
	m.tool_invocations = nil
	m.clearedtool_invocations = false
	m.removedtool_invocations = nil
}

// AddEventIDs adds the "events" edge to the AgentEvent entity by ids.
func (m *AgentTaskMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the AgentEvent entity.
func (m *AgentTaskMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the AgentEvent entity was cleared.
func (m *AgentTaskMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the AgentEvent entity by IDs.
func (m *AgentTaskMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the AgentEvent entity.
func (m *AgentTaskMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *AgentTaskMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *AgentTaskMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the AgentTaskMutation builder.
func (m *AgentTaskMutation) Where(ps ...predicate.AgentTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentTask).
func (m *AgentTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentTaskMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.workflow != nil {
		fields = append(fields, agenttask.FieldWorkflowID)
	}
	if m.agent_id != nil {
		fields = append(fields, agenttask.FieldAgentID)
	}
	if m.agent_type != nil {
		fields = append(fields, agenttask.FieldAgentType)
	}
	if m.task_type != nil {
		fields = append(fields, agenttask.FieldTaskType)
	}
	if m.name != nil {
		fields = append(fields, agenttask.FieldName)
	}
	if m.status != nil {
		fields = append(fields, agenttask.FieldStatus)
	}
	if m.trace_id != nil {
		fields = append(fields, agenttask.FieldTraceID)
	}
	if m.span_id != nil {
		fields = append(fields, agenttask.FieldSpanID)
	}
	if m.parent_span_id != nil {
		fields = append(fields, agenttask.FieldParentSpanID)
	}
	if m.input != nil {
		fields = append(fields, agenttask.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, agenttask.FieldOutput)
	}
	if m.metadata != nil {
		fields = append(fields, agenttask.FieldMetadata)
	}
	if m.llm_call_count != nil {
		fields = append(fields, agenttask.FieldLlmCallCount)
	}
	if m.tool_call_count != nil {
		fields = append(fields, agenttask.FieldToolCallCount)
	}
	if m.retry_count != nil {
		fields = append(fields, agenttask.FieldRetryCount)
	}
	if m.tokens_prompt != nil {
		fields = append(fields, agenttask.FieldTokensPrompt)
	}
	if m.tokens_completion != nil {
		fields = append(fields, agenttask.FieldTokensCompletion)
	}
	if m.tokens_total != nil {
		fields = append(fields, agenttask.FieldTokensTotal)
	}
	if m.cost_usd != nil {
		fields = append(fields, agenttask.FieldCostUsd)
	}
	if m.duration_ms != nil {
		fields = append(fields, agenttask.FieldDurationMs)
	}
	if m.error_type != nil {
		fields = append(fields, agenttask.FieldErrorType)
	}
	if m.error_message != nil {
		fields = append(fields, agenttask.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, agenttask.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, agenttask.FieldEndedAt)
	}
	if m.created_at != nil {
		fields = append(fields, agenttask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agenttask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agenttask.FieldWorkflowID:
		return m.WorkflowID()
	case agenttask.FieldAgentID:
		return m.AgentID()
	case agenttask.FieldAgentType:
		return m.AgentType()
	case agenttask.FieldTaskType:
		return m.TaskType()
	case agenttask.FieldName:
		return m.Name()
	case agenttask.FieldStatus:
		return m.Status()
	case agenttask.FieldTraceID:
		return m.TraceID()
	case agenttask.FieldSpanID:
		return m.SpanID()
	case agenttask.FieldParentSpanID:
		return m.ParentSpanID()
	case agenttask.FieldInput:
		return m.Input()
	case agenttask.FieldOutput:
		return m.Output()
	case agenttask.FieldMetadata:
		return m.Metadata()
	case agenttask.FieldLlmCallCount:
		return m.LlmCallCount()
	case agenttask.FieldToolCallCount:
		return m.ToolCallCount()
	case agenttask.FieldRetryCount:
		return m.RetryCount()
	case agenttask.FieldTokensPrompt:
		return m.TokensPrompt()
	case agenttask.FieldTokensCompletion:
		return m.TokensCompletion()
	case agenttask.FieldTokensTotal:
		return m.TokensTotal()
	case agenttask.FieldCostUsd:
		return m.CostUsd()
	case agenttask.FieldDurationMs:
		return m.DurationMs()
	case agenttask.FieldErrorType:
		return m.ErrorType()
	case agenttask.FieldErrorMessage:
		return m.ErrorMessage()
	case agenttask.FieldStartedAt:
		return m.StartedAt()
	case agenttask.FieldEndedAt:
		return m.EndedAt()
	case agenttask.FieldCreatedAt:
		return m.CreatedAt()
	case agenttask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agenttask.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case agenttask.FieldAgentID:
		return m.OldAgentID(ctx)
	case agenttask.FieldAgentType:
		return m.OldAgentType(ctx)
	case agenttask.FieldTaskType:
		return m.OldTaskType(ctx)
	case agenttask.FieldName:
		return m.OldName(ctx)
	case agenttask.FieldStatus:
		return m.OldStatus(ctx)
	case agenttask.FieldTraceID:
		return m.OldTraceID(ctx)
	case agenttask.FieldSpanID:
		return m.OldSpanID(ctx)
	case agenttask.FieldParentSpanID:
		return m.OldParentSpanID(ctx)
	case agenttask.FieldInput:
		return m.OldInput(ctx)
	case agenttask.FieldOutput:
		return m.OldOutput(ctx)
	case agenttask.FieldMetadata:
		return m.OldMetadata(ctx)
	case agenttask.FieldLlmCallCount:
		return m.OldLlmCallCount(ctx)
	case agenttask.FieldToolCallCount:
		return m.OldToolCallCount(ctx)
	case agenttask.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case agenttask.FieldTokensPrompt:
		return m.OldTokensPrompt(ctx)
	case agenttask.FieldTokensCompletion:
		return m.OldTokensCompletion(ctx)
	case agenttask.FieldTokensTotal:
		return m.OldTokensTotal(ctx)
	case agenttask.FieldCostUsd:
		return m.OldCostUsd(ctx)
	case agenttask.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case agenttask.FieldErrorType:
		return m.OldErrorType(ctx)
	case agenttask.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case agenttask.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case agenttask.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case agenttask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agenttask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AgentTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agenttask.FieldWorkflowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case agenttask.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case agenttask.FieldAgentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentType(v)
		return nil
	case agenttask.FieldTaskType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskType(v)
		return nil
	case agenttask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case agenttask.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agenttask.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case agenttask.FieldSpanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpanID(v)
		return nil
	case agenttask.FieldParentSpanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentSpanID(v)
		return nil
	case agenttask.FieldInput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case agenttask.FieldOutput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case agenttask.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case agenttask.FieldLlmCallCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLlmCallCount(v)
		return nil
	case agenttask.FieldToolCallCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolCallCount(v)
		return nil
	case agenttask.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case agenttask.FieldTokensPrompt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokensPrompt(v)
		return nil
	case agenttask.FieldTokensCompletion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokensCompletion(v)
		return nil
	case agenttask.FieldTokensTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokensTotal(v)
		return nil
	case agenttask.FieldCostUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostUsd(v)
		return nil
	case agenttask.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case agenttask.FieldErrorType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorType(v)
		return nil
	case agenttask.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case agenttask.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case agenttask.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case agenttask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agenttask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AgentTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentTaskMutation) AddedFields() []string {
	var fields []string
	if m.addllm_call_count != nil {
		fields = append(fields, agenttask.FieldLlmCallCount)
	}
	if m.addtool_call_count != nil {
		fields = append(fields, agenttask.FieldToolCallCount)
	}
	if m.addretry_count != nil {
		fields = append(fields, agenttask.FieldRetryCount)
	}
	if m.addtokens_prompt != nil {
		fields = append(fields, agenttask.FieldTokensPrompt)
	}
	if m.addtokens_completion != nil {
		fields = append(fields, agenttask.FieldTokensCompletion)
	}
	if m.addtokens_total != nil {
		fields = append(fields, agenttask.FieldTokensTotal)
	}
	if m.addcost_usd != nil {
		fields = append(fields, agenttask.FieldCostUsd)
	}
	if m.addduration_ms != nil {
		fields = append(fields, agenttask.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agenttask.FieldLlmCallCount:
		return m.AddedLlmCallCount()
	case agenttask.FieldToolCallCount:
		return m.AddedToolCallCount()
	case agenttask.FieldRetryCount:
		return m.AddedRetryCount()
	case agenttask.FieldTokensPrompt:
		return m.AddedTokensPrompt()
	case agenttask.FieldTokensCompletion:
		return m.AddedTokensCompletion()
	case agenttask.FieldTokensTotal:
		return m.AddedTokensTotal()
	case agenttask.FieldCostUsd:
		return m.AddedCostUsd()
	case agenttask.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agenttask.FieldLlmCallCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLlmCallCount(v)
		return nil
	case agenttask.FieldToolCallCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToolCallCount(v)
		return nil
	case agenttask.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case agenttask.FieldTokensPrompt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokensPrompt(v)
		return nil
	case agenttask.FieldTokensCompletion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokensCompletion(v)
		return nil
	case agenttask.FieldTokensTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokensTotal(v)
		return nil
	case agenttask.FieldCostUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostUsd(v)
		return nil
	case agenttask.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown AgentTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agenttask.FieldWorkflowID) {
		fields = append(fields, agenttask.FieldWorkflowID)
	}
	if m.FieldCleared(agenttask.FieldAgentType) {
		fields = append(fields, agenttask.FieldAgentType)
	}
	if m.FieldCleared(agenttask.FieldTraceID) {
		fields = append(fields, agenttask.FieldTraceID)
	}
	if m.FieldCleared(agenttask.FieldSpanID) {
		fields = append(fields, agenttask.FieldSpanID)
	}
	if m.FieldCleared(agenttask.FieldParentSpanID) {
		fields = append(fields, agenttask.FieldParentSpanID)
	}
	if m.FieldCleared(agenttask.FieldInput) {
		fields = append(fields, agenttask.FieldInput)
	}
	if m.FieldCleared(agenttask.FieldOutput) {
		fields = append(fields, agenttask.FieldOutput)
	}
	if m.FieldCleared(agenttask.FieldMetadata) {
		fields = append(fields, agenttask.FieldMetadata)
	}
	if m.FieldCleared(agenttask.FieldDurationMs) {
		fields = append(fields, agenttask.FieldDurationMs)
	}
	if m.FieldCleared(agenttask.FieldErrorType) {
		fields = append(fields, agenttask.FieldErrorType)
	}
	if m.FieldCleared(agenttask.FieldErrorMessage) {
		fields = append(fields, agenttask.FieldErrorMessage)
	}
	if m.FieldCleared(agenttask.FieldEndedAt) {
		fields = append(fields, agenttask.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentTaskMutation) ClearField(name string) error {
	switch name {
	case agenttask.FieldWorkflowID:
		m.ClearWorkflowID()
		return nil
	case agenttask.FieldAgentType:
		m.ClearAgentType()
		return nil
	case agenttask.FieldTraceID:
		m.ClearTraceID()
		return nil
	case agenttask.FieldSpanID:
		m.ClearSpanID()
		return nil
	case agenttask.FieldParentSpanID:
		m.ClearParentSpanID()
		return nil
	case agenttask.FieldInput:
		m.ClearInput()
		return nil
	case agenttask.FieldOutput:
		m.ClearOutput()
		return nil
	case agenttask.FieldMetadata:
		m.ClearMetadata()
		return nil
	case agenttask.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case agenttask.FieldErrorType:
		m.ClearErrorType()
		return nil
	case agenttask.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case agenttask.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown AgentTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentTaskMutation) ResetField(name string) error {
	switch name {
	case agenttask.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case agenttask.FieldAgentID:
		m.ResetAgentID()
		return nil
	case agenttask.FieldAgentType:
		m.ResetAgentType()
		return nil
	case agenttask.FieldTaskType:
		m.ResetTaskType()
		return nil
	case agenttask.FieldName:
		m.ResetName()
		return nil
	case agenttask.FieldStatus:
		m.ResetStatus()
		return nil
	case agenttask.FieldTraceID:
		m.ResetTraceID()
		return nil
	case agenttask.FieldSpanID:
		m.ResetSpanID()
		return nil
	case agenttask.FieldParentSpanID:
		m.ResetParentSpanID()
		return nil
	case agenttask.FieldInput:
		m.ResetInput()
		return nil
	case agenttask.FieldOutput:
		m.ResetOutput()
		return nil
	case agenttask.FieldMetadata:
		m.ResetMetadata()
		return nil
	case agenttask.FieldLlmCallCount:
		m.ResetLlmCallCount()
		return nil
	case agenttask.FieldToolCallCount:
		m.ResetToolCallCount()
		return nil
	case agenttask.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case agenttask.FieldTokensPrompt:
		m.ResetTokensPrompt()
		return nil
	case agenttask.FieldTokensCompletion:
		m.ResetTokensCompletion()
		return nil
	case agenttask.FieldTokensTotal:
		m.ResetTokensTotal()
		return nil
	case agenttask.FieldCostUsd:
		m.ResetCostUsd()
		return nil
	case agenttask.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case agenttask.FieldErrorType:
		m.ResetErrorType()
		return nil
	case agenttask.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case agenttask.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case agenttask.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case agenttask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agenttask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AgentTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, agenttask.EdgeWorkflow)
	}
	if m.tool_invocations != nil {
		edges = append(edges, agenttask.EdgeToolInvocations)
	}
	if m.events != nil {
		edges = append(edges, agenttask.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agenttask.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case agenttask.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.tool_invocations))
		for id := range m.tool_invocations {
			ids = append(ids, id)
		}
		return ids
	case agenttask.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtool_invocations != nil {
		edges = append(edges, agenttask.EdgeToolInvocations)
	}
	if m.removedevents != nil {
		edges = append(edges, agenttask.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agenttask.EdgeToolInvocations:
		ids := make([]ent.Value, 0, len(m.removedtool_invocations))
		for id := range m.removedtool_invocations {
			ids = append(ids, id)
		}
		return ids
	case agenttask.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, agenttask.EdgeWorkflow)
	}
	if m.clearedtool_invocations {
		edges = append(edges, agenttask.EdgeToolInvocations)
	}
	if m.clearedevents {
		edges = append(edges, agenttask.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case agenttask.EdgeWorkflow:
		return m.clearedworkflow
	case agenttask.EdgeToolInvocations:
		return m.clearedtool_invocations
	case agenttask.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentTaskMutation) ClearEdge(name string) error {
	switch name {
	case agenttask.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown AgentTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentTaskMutation) ResetEdge(name string) error {
	switch name {
	case agenttask.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case agenttask.EdgeToolInvocations:
		m.ResetToolInvocations()
		return nil
	case agenttask.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown AgentTask edge %s", name)
}

// ToolInvocationMutation represents an operation that mutates the ToolInvocation nodes in the graph.
type ToolInvocationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	agent_id               *string
	tool_name              *string
	tool_type              *string
	status                 *string
	trace_id               *string
	span_id                *string
	input                  *map[string]interface{}
	output                 *map[string]interface{}
	metadata               *map[string]interface{}
	http_method            *string
	http_url               *string
	http_status_code       *int
	addhttp_status_code    *int
	duration_ms            *int64
	addduration_ms         *int64
	request_size_bytes     *int
	addrequest_size_bytes  *int
	response_size_bytes    *int
	addresponse_size_bytes *int
	retry_count            *int
	addretry_count         *int
	error_type             *string
	error_message          *string
	started_at             *time.Time
	ended_at               *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	task                   *string
	clearedtask            bool
	done                   bool
	oldValue               func(context.Context) (*ToolInvocation, error)
	predicates             []predicate.ToolInvocation
}

var _ ent.Mutation = (*ToolInvocationMutation)(nil)

// toolinvocationOption allows management of the mutation configuration using functional options.
type toolinvocationOption func(*ToolInvocationMutation)

// newToolInvocationMutation creates new mutation for the ToolInvocation entity.
func newToolInvocationMutation(c config, op Op, opts ...toolinvocationOption) *ToolInvocationMutation {
	m := &ToolInvocationMutation{
		config:        c,
		op:            op,
		typ:           TypeToolInvocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolInvocationID sets the ID field of the mutation.
func withToolInvocationID(id string) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		var (
			err   error
			once  sync.Once
			value *ToolInvocation
		)
		m.oldValue = func(ctx context.Context) (*ToolInvocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ToolInvocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToolInvocation sets the old ToolInvocation of the mutation.
func withToolInvocation(node *ToolInvocation) toolinvocationOption {
	return func(m *ToolInvocationMutation) {
		m.oldValue = func(context.Context) (*ToolInvocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolInvocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolInvocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ToolInvocation entities.
func (m *ToolInvocationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ToolInvocationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ToolInvocationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ToolInvocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *ToolInvocationMutation) SetTaskID(s string) {
	m.task = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *ToolInvocationMutation) TaskID() (r string, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *ToolInvocationMutation) ClearTaskID() {
	m.task = nil
	m.clearedFields[toolinvocation.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *ToolInvocationMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *ToolInvocationMutation) ResetTaskID() {
	m.task = nil
	delete(m.clearedFields, toolinvocation.FieldTaskID)
}

// SetAgentID sets the "agent_id" field.
func (m *ToolInvocationMutation) SetAgentID(s string) {
	m.agent_id = &s
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *ToolInvocationMutation) AgentID() (r string, exists bool) {
	v := m.agent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldAgentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *ToolInvocationMutation) ResetAgentID() {
	m.agent_id = nil
}

// SetToolName sets the "tool_name" field.
func (m *ToolInvocationMutation) SetToolName(s string) {
	m.tool_name = &s
}

// ToolName returns the value of the "tool_name" field in the mutation.
func (m *ToolInvocationMutation) ToolName() (r string, exists bool) {
	v := m.tool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old "tool_name" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldToolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ResetToolName resets all changes to the "tool_name" field.
func (m *ToolInvocationMutation) ResetToolName() {
	m.tool_name = nil
}

// SetToolType sets the "tool_type" field.
func (m *ToolInvocationMutation) SetToolType(s string) {
	m.tool_type = &s
}

// ToolType returns the value of the "tool_type" field in the mutation.
func (m *ToolInvocationMutation) ToolType() (r string, exists bool) {
	v := m.tool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldToolType returns the old "tool_type" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldToolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolType: %w", err)
	}
	return oldValue.ToolType, nil
}

// ClearToolType clears the value of the "tool_type" field.
func (m *ToolInvocationMutation) ClearToolType() {
	m.tool_type = nil
	m.clearedFields[toolinvocation.FieldToolType] = struct{}{}
}

// ToolTypeCleared returns if the "tool_type" field was cleared in this mutation.
func (m *ToolInvocationMutation) ToolTypeCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldToolType]
	return ok
}

// ResetToolType resets all changes to the "tool_type" field.
func (m *ToolInvocationMutation) ResetToolType() {
	m.tool_type = nil
	delete(m.clearedFields, toolinvocation.FieldToolType)
}

// SetStatus sets the "status" field.
func (m *ToolInvocationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ToolInvocationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ToolInvocationMutation) ResetStatus() {
	m.status = nil
}

// SetTraceID sets the "trace_id" field.
func (m *ToolInvocationMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *ToolInvocationMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *ToolInvocationMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[toolinvocation.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *ToolInvocationMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *ToolInvocationMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, toolinvocation.FieldTraceID)
}

// SetSpanID sets the "span_id" field.
func (m *ToolInvocationMutation) SetSpanID(s string) {
	m.span_id = &s
}

// SpanID returns the value of the "span_id" field in the mutation.
func (m *ToolInvocationMutation) SpanID() (r string, exists bool) {
	v := m.span_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpanID returns the old "span_id" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldSpanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpanID: %w", err)
	}
	return oldValue.SpanID, nil
}

// ClearSpanID clears the value of the "span_id" field.
func (m *ToolInvocationMutation) ClearSpanID() {
	m.span_id = nil
	m.clearedFields[toolinvocation.FieldSpanID] = struct{}{}
}

// SpanIDCleared returns if the "span_id" field was cleared in this mutation.
func (m *ToolInvocationMutation) SpanIDCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldSpanID]
	return ok
}

// ResetSpanID resets all changes to the "span_id" field.
func (m *ToolInvocationMutation) ResetSpanID() {
	m.span_id = nil
	delete(m.clearedFields, toolinvocation.FieldSpanID)
}

// SetInput sets the "input" field.
func (m *ToolInvocationMutation) SetInput(value map[string]interface{}) {
	m.input = &value
}

// Input returns the value of the "input" field in the mutation.
func (m *ToolInvocationMutation) Input() (r map[string]interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldInput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ClearInput clears the value of the "input" field.
func (m *ToolInvocationMutation) ClearInput() {
	m.input = nil
	m.clearedFields[toolinvocation.FieldInput] = struct{}{}
}

// InputCleared returns if the "input" field was cleared in this mutation.
func (m *ToolInvocationMutation) InputCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldInput]
	return ok
}

// ResetInput resets all changes to the "input" field.
func (m *ToolInvocationMutation) ResetInput() {
	m.input = nil
	delete(m.clearedFields, toolinvocation.FieldInput)
}

// SetOutput sets the "output" field.
func (m *ToolInvocationMutation) SetOutput(value map[string]interface{}) {
	m.output = &value
}

// Output returns the value of the "output" field in the mutation.
func (m *ToolInvocationMutation) Output() (r map[string]interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldOutput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *ToolInvocationMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[toolinvocation.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *ToolInvocationMutation) OutputCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *ToolInvocationMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, toolinvocation.FieldOutput)
}

// SetMetadata sets the "metadata" field.
func (m *ToolInvocationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *ToolInvocationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *ToolInvocationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[toolinvocation.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *ToolInvocationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *ToolInvocationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, toolinvocation.FieldMetadata)
}

// SetHTTPMethod sets the "http_method" field.
func (m *ToolInvocationMutation) SetHTTPMethod(s string) {
	m.http_method = &s
}

// HTTPMethod returns the value of the "http_method" field in the mutation.
func (m *ToolInvocationMutation) HTTPMethod() (r string, exists bool) {
	v := m.http_method
	if v == nil {
		return
	}
	return *v, true
}

// OldHTTPMethod returns the old "http_method" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldHTTPMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTTPMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTTPMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTTPMethod: %w", err)
	}
	return oldValue.HTTPMethod, nil
}

// ClearHTTPMethod clears the value of the "http_method" field.
func (m *ToolInvocationMutation) ClearHTTPMethod() {
	m.http_method = nil
	m.clearedFields[toolinvocation.FieldHTTPMethod] = struct{}{}
}

// HTTPMethodCleared returns if the "http_method" field was cleared in this mutation.
func (m *ToolInvocationMutation) HTTPMethodCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldHTTPMethod]
	return ok
}

// ResetHTTPMethod resets all changes to the "http_method" field.
func (m *ToolInvocationMutation) ResetHTTPMethod() {
	m.http_method = nil
	delete(m.clearedFields, toolinvocation.FieldHTTPMethod)
}

// SetHTTPURL sets the "http_url" field.
func (m *ToolInvocationMutation) SetHTTPURL(s string) {
	m.http_url = &s
}

// HTTPURL returns the value of the "http_url" field in the mutation.
func (m *ToolInvocationMutation) HTTPURL() (r string, exists bool) {
	v := m.http_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHTTPURL returns the old "http_url" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldHTTPURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTTPURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTTPURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTTPURL: %w", err)
	}
	return oldValue.HTTPURL, nil
}

// ClearHTTPURL clears the value of the "http_url" field.
func (m *ToolInvocationMutation) ClearHTTPURL() {
	m.http_url = nil
	m.clearedFields[toolinvocation.FieldHTTPURL] = struct{}{}
}

// HTTPURLCleared returns if the "http_url" field was cleared in this mutation.
func (m *ToolInvocationMutation) HTTPURLCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldHTTPURL]
	return ok
}

// ResetHTTPURL resets all changes to the "http_url" field.
func (m *ToolInvocationMutation) ResetHTTPURL() {
	m.http_url = nil
	delete(m.clearedFields, toolinvocation.FieldHTTPURL)
}

// SetHTTPStatusCode sets the "http_status_code" field.
func (m *ToolInvocationMutation) SetHTTPStatusCode(i int) {
	m.http_status_code = &i
	m.addhttp_status_code = nil
}

// HTTPStatusCode returns the value of the "http_status_code" field in the mutation.
func (m *ToolInvocationMutation) HTTPStatusCode() (r int, exists bool) {
	v := m.http_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldHTTPStatusCode returns the old "http_status_code" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldHTTPStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTTPStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTTPStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTTPStatusCode: %w", err)
	}
	return oldValue.HTTPStatusCode, nil
}

// AddHTTPStatusCode adds i to the "http_status_code" field.
func (m *ToolInvocationMutation) AddHTTPStatusCode(i int) {
	if m.addhttp_status_code != nil {
		*m.addhttp_status_code += i
	} else {
		m.addhttp_status_code = &i
	}
}

// AddedHTTPStatusCode returns the value that was added to the "http_status_code" field in this mutation.
func (m *ToolInvocationMutation) AddedHTTPStatusCode() (r int, exists bool) {
	v := m.addhttp_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearHTTPStatusCode clears the value of the "http_status_code" field.
func (m *ToolInvocationMutation) ClearHTTPStatusCode() {
	m.http_status_code = nil
	m.addhttp_status_code = nil
	m.clearedFields[toolinvocation.FieldHTTPStatusCode] = struct{}{}
}

// HTTPStatusCodeCleared returns if the "http_status_code" field was cleared in this mutation.
func (m *ToolInvocationMutation) HTTPStatusCodeCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldHTTPStatusCode]
	return ok
}

// ResetHTTPStatusCode resets all changes to the "http_status_code" field.
func (m *ToolInvocationMutation) ResetHTTPStatusCode() {
	m.http_status_code = nil
	m.addhttp_status_code = nil
	delete(m.clearedFields, toolinvocation.FieldHTTPStatusCode)
}

// SetDurationMs sets the "duration_ms" field.
func (m *ToolInvocationMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *ToolInvocationMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *ToolInvocationMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *ToolInvocationMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *ToolInvocationMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[toolinvocation.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *ToolInvocationMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *ToolInvocationMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, toolinvocation.FieldDurationMs)
}

// SetRequestSizeBytes sets the "request_size_bytes" field.
func (m *ToolInvocationMutation) SetRequestSizeBytes(i int) {
	m.request_size_bytes = &i
	m.addrequest_size_bytes = nil
}

// RequestSizeBytes returns the value of the "request_size_bytes" field in the mutation.
func (m *ToolInvocationMutation) RequestSizeBytes() (r int, exists bool) {
	v := m.request_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestSizeBytes returns the old "request_size_bytes" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldRequestSizeBytes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestSizeBytes: %w", err)
	}
	return oldValue.RequestSizeBytes, nil
}

// AddRequestSizeBytes adds i to the "request_size_bytes" field.
func (m *ToolInvocationMutation) AddRequestSizeBytes(i int) {
	if m.addrequest_size_bytes != nil {
		*m.addrequest_size_bytes += i
	} else {
		m.addrequest_size_bytes = &i
	}
}

// AddedRequestSizeBytes returns the value that was added to the "request_size_bytes" field in this mutation.
func (m *ToolInvocationMutation) AddedRequestSizeBytes() (r int, exists bool) {
	v := m.addrequest_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestSizeBytes resets all changes to the "request_size_bytes" field.
func (m *ToolInvocationMutation) ResetRequestSizeBytes() {
	m.request_size_bytes = nil
	m.addrequest_size_bytes = nil
}

// SetResponseSizeBytes sets the "response_size_bytes" field.
func (m *ToolInvocationMutation) SetResponseSizeBytes(i int) {
	m.response_size_bytes = &i
	m.addresponse_size_bytes = nil
}

// ResponseSizeBytes returns the value of the "response_size_bytes" field in the mutation.
func (m *ToolInvocationMutation) ResponseSizeBytes() (r int, exists bool) {
	v := m.response_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseSizeBytes returns the old "response_size_bytes" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldResponseSizeBytes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseSizeBytes: %w", err)
	}
	return oldValue.ResponseSizeBytes, nil
}

// AddResponseSizeBytes adds i to the "response_size_bytes" field.
func (m *ToolInvocationMutation) AddResponseSizeBytes(i int) {
	if m.addresponse_size_bytes != nil {
		*m.addresponse_size_bytes += i
	} else {
		m.addresponse_size_bytes = &i
	}
}

// AddedResponseSizeBytes returns the value that was added to the "response_size_bytes" field in this mutation.
func (m *ToolInvocationMutation) AddedResponseSizeBytes() (r int, exists bool) {
	v := m.addresponse_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetResponseSizeBytes resets all changes to the "response_size_bytes" field.
func (m *ToolInvocationMutation) ResetResponseSizeBytes() {
	m.response_size_bytes = nil
	m.addresponse_size_bytes = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *ToolInvocationMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *ToolInvocationMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *ToolInvocationMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *ToolInvocationMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *ToolInvocationMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetErrorType sets the "error_type" field.
func (m *ToolInvocationMutation) SetErrorType(s string) {
	m.error_type = &s
}

// ErrorType returns the value of the "error_type" field in the mutation.
func (m *ToolInvocationMutation) ErrorType() (r string, exists bool) {
	v := m.error_type
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorType returns the old "error_type" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldErrorType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorType: %w", err)
	}
	return oldValue.ErrorType, nil
}

// ClearErrorType clears the value of the "error_type" field.
func (m *ToolInvocationMutation) ClearErrorType() {
	m.error_type = nil
	m.clearedFields[toolinvocation.FieldErrorType] = struct{}{}
}

// ErrorTypeCleared returns if the "error_type" field was cleared in this mutation.
func (m *ToolInvocationMutation) ErrorTypeCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldErrorType]
	return ok
}

// ResetErrorType resets all changes to the "error_type" field.
func (m *ToolInvocationMutation) ResetErrorType() {
	m.error_type = nil
	delete(m.clearedFields, toolinvocation.FieldErrorType)
}

// SetErrorMessage sets the "error_message" field.
func (m *ToolInvocationMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *ToolInvocationMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *ToolInvocationMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[toolinvocation.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *ToolInvocationMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *ToolInvocationMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, toolinvocation.FieldErrorMessage)
}

// SetStartedAt sets the "started_at" field.
func (m *ToolInvocationMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *ToolInvocationMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *ToolInvocationMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *ToolInvocationMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *ToolInvocationMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *ToolInvocationMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[toolinvocation.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *ToolInvocationMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[toolinvocation.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *ToolInvocationMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, toolinvocation.FieldEndedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ToolInvocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ToolInvocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ToolInvocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ToolInvocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ToolInvocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ToolInvocation entity.
// If the ToolInvocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ToolInvocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ToolInvocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the AgentTask entity.
func (m *ToolInvocationMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[toolinvocation.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the AgentTask entity was cleared.
func (m *ToolInvocationMutation) TaskCleared() bool {
	return m.TaskIDCleared() || m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ToolInvocationMutation) TaskIDs() (ids []string) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *ToolInvocationMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the ToolInvocationMutation builder.
func (m *ToolInvocationMutation) Where(ps ...predicate.ToolInvocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ToolInvocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ToolInvocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ToolInvocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ToolInvocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ToolInvocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ToolInvocation).
func (m *ToolInvocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ToolInvocationMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.task != nil {
		fields = append(fields, toolinvocation.FieldTaskID)
	}
	if m.agent_id != nil {
		fields = append(fields, toolinvocation.FieldAgentID)
	}
	if m.tool_name != nil {
		fields = append(fields, toolinvocation.FieldToolName)
	}
	if m.tool_type != nil {
		fields = append(fields, toolinvocation.FieldToolType)
	}
	if m.status != nil {
		fields = append(fields, toolinvocation.FieldStatus)
	}
	if m.trace_id != nil {
		fields = append(fields, toolinvocation.FieldTraceID)
	}
	if m.span_id != nil {
		fields = append(fields, toolinvocation.FieldSpanID)
	}
	if m.input != nil {
		fields = append(fields, toolinvocation.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, toolinvocation.FieldOutput)
	}
	if m.metadata != nil {
		fields = append(fields, toolinvocation.FieldMetadata)
	}
	if m.http_method != nil {
		fields = append(fields, toolinvocation.FieldHTTPMethod)
	}
	if m.http_url != nil {
		fields = append(fields, toolinvocation.FieldHTTPURL)
	}
	if m.http_status_code != nil {
		fields = append(fields, toolinvocation.FieldHTTPStatusCode)
	}
	if m.duration_ms != nil {
		fields = append(fields, toolinvocation.FieldDurationMs)
	}
	if m.request_size_bytes != nil {
		fields = append(fields, toolinvocation.FieldRequestSizeBytes)
	}
	if m.response_size_bytes != nil {
		fields = append(fields, toolinvocation.FieldResponseSizeBytes)
	}
	if m.retry_count != nil {
		fields = append(fields, toolinvocation.FieldRetryCount)
	}
	if m.error_type != nil {
		fields = append(fields, toolinvocation.FieldErrorType)
	}
	if m.error_message != nil {
		fields = append(fields, toolinvocation.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, toolinvocation.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, toolinvocation.FieldEndedAt)
	}
	if m.created_at != nil {
		fields = append(fields, toolinvocation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, toolinvocation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ToolInvocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldTaskID:
		return m.TaskID()
	case toolinvocation.FieldAgentID:
		return m.AgentID()
	case toolinvocation.FieldToolName:
		return m.ToolName()
	case toolinvocation.FieldToolType:
		return m.ToolType()
	case toolinvocation.FieldStatus:
		return m.Status()
	case toolinvocation.FieldTraceID:
		return m.TraceID()
	case toolinvocation.FieldSpanID:
		return m.SpanID()
	case toolinvocation.FieldInput:
		return m.Input()
	case toolinvocation.FieldOutput:
		return m.Output()
	case toolinvocation.FieldMetadata:
		return m.Metadata()
	case toolinvocation.FieldHTTPMethod:
		return m.HTTPMethod()
	case toolinvocation.FieldHTTPURL:
		return m.HTTPURL()
	case toolinvocation.FieldHTTPStatusCode:
		return m.HTTPStatusCode()
	case toolinvocation.FieldDurationMs:
		return m.DurationMs()
	case toolinvocation.FieldRequestSizeBytes:
		return m.RequestSizeBytes()
	case toolinvocation.FieldResponseSizeBytes:
		return m.ResponseSizeBytes()
	case toolinvocation.FieldRetryCount:
		return m.RetryCount()
	case toolinvocation.FieldErrorType:
		return m.ErrorType()
	case toolinvocation.FieldErrorMessage:
		return m.ErrorMessage()
	case toolinvocation.FieldStartedAt:
		return m.StartedAt()
	case toolinvocation.FieldEndedAt:
		return m.EndedAt()
	case toolinvocation.FieldCreatedAt:
		return m.CreatedAt()
	case toolinvocation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ToolInvocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case toolinvocation.FieldTaskID:
		return m.OldTaskID(ctx)
	case toolinvocation.FieldAgentID:
		return m.OldAgentID(ctx)
	case toolinvocation.FieldToolName:
		return m.OldToolName(ctx)
	case toolinvocation.FieldToolType:
		return m.OldToolType(ctx)
	case toolinvocation.FieldStatus:
		return m.OldStatus(ctx)
	case toolinvocation.FieldTraceID:
		return m.OldTraceID(ctx)
	case toolinvocation.FieldSpanID:
		return m.OldSpanID(ctx)
	case toolinvocation.FieldInput:
		return m.OldInput(ctx)
	case toolinvocation.FieldOutput:
		return m.OldOutput(ctx)
	case toolinvocation.FieldMetadata:
		return m.OldMetadata(ctx)
	case toolinvocation.FieldHTTPMethod:
		return m.OldHTTPMethod(ctx)
	case toolinvocation.FieldHTTPURL:
		return m.OldHTTPURL(ctx)
	case toolinvocation.FieldHTTPStatusCode:
		return m.OldHTTPStatusCode(ctx)
	case toolinvocation.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case toolinvocation.FieldRequestSizeBytes:
		return m.OldRequestSizeBytes(ctx)
	case toolinvocation.FieldResponseSizeBytes:
		return m.OldResponseSizeBytes(ctx)
	case toolinvocation.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case toolinvocation.FieldErrorType:
		return m.OldErrorType(ctx)
	case toolinvocation.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case toolinvocation.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case toolinvocation.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case toolinvocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case toolinvocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ToolInvocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case toolinvocation.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case toolinvocation.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	case toolinvocation.FieldToolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolType(v)
		return nil
	case toolinvocation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case toolinvocation.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case toolinvocation.FieldSpanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpanID(v)
		return nil
	case toolinvocation.FieldInput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case toolinvocation.FieldOutput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case toolinvocation.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case toolinvocation.FieldHTTPMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTTPMethod(v)
		return nil
	case toolinvocation.FieldHTTPURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTTPURL(v)
		return nil
	case toolinvocation.FieldHTTPStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTTPStatusCode(v)
		return nil
	case toolinvocation.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case toolinvocation.FieldRequestSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestSizeBytes(v)
		return nil
	case toolinvocation.FieldResponseSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseSizeBytes(v)
		return nil
	case toolinvocation.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case toolinvocation.FieldErrorType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorType(v)
		return nil
	case toolinvocation.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case toolinvocation.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case toolinvocation.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case toolinvocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case toolinvocation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ToolInvocationMutation) AddedFields() []string {
	var fields []string
	if m.addhttp_status_code != nil {
		fields = append(fields, toolinvocation.FieldHTTPStatusCode)
	}
	if m.addduration_ms != nil {
		fields = append(fields, toolinvocation.FieldDurationMs)
	}
	if m.addrequest_size_bytes != nil {
		fields = append(fields, toolinvocation.FieldRequestSizeBytes)
	}
	if m.addresponse_size_bytes != nil {
		fields = append(fields, toolinvocation.FieldResponseSizeBytes)
	}
	if m.addretry_count != nil {
		fields = append(fields, toolinvocation.FieldRetryCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ToolInvocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case toolinvocation.FieldHTTPStatusCode:
		return m.AddedHTTPStatusCode()
	case toolinvocation.FieldDurationMs:
		return m.AddedDurationMs()
	case toolinvocation.FieldRequestSizeBytes:
		return m.AddedRequestSizeBytes()
	case toolinvocation.FieldResponseSizeBytes:
		return m.AddedResponseSizeBytes()
	case toolinvocation.FieldRetryCount:
		return m.AddedRetryCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ToolInvocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case toolinvocation.FieldHTTPStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHTTPStatusCode(v)
		return nil
	case toolinvocation.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	case toolinvocation.FieldRequestSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestSizeBytes(v)
		return nil
	case toolinvocation.FieldResponseSizeBytes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseSizeBytes(v)
		return nil
	case toolinvocation.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ToolInvocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(toolinvocation.FieldTaskID) {
		fields = append(fields, toolinvocation.FieldTaskID)
	}
	if m.FieldCleared(toolinvocation.FieldToolType) {
		fields = append(fields, toolinvocation.FieldToolType)
	}
	if m.FieldCleared(toolinvocation.FieldTraceID) {
		fields = append(fields, toolinvocation.FieldTraceID)
	}
	if m.FieldCleared(toolinvocation.FieldSpanID) {
		fields = append(fields, toolinvocation.FieldSpanID)
	}
	if m.FieldCleared(toolinvocation.FieldInput) {
		fields = append(fields, toolinvocation.FieldInput)
	}
	if m.FieldCleared(toolinvocation.FieldOutput) {
		fields = append(fields, toolinvocation.FieldOutput)
	}
	if m.FieldCleared(toolinvocation.FieldMetadata) {
		fields = append(fields, toolinvocation.FieldMetadata)
	}
	if m.FieldCleared(toolinvocation.FieldHTTPMethod) {
		fields = append(fields, toolinvocation.FieldHTTPMethod)
	}
	if m.FieldCleared(toolinvocation.FieldHTTPURL) {
		fields = append(fields, toolinvocation.FieldHTTPURL)
	}
	if m.FieldCleared(toolinvocation.FieldHTTPStatusCode) {
		fields = append(fields, toolinvocation.FieldHTTPStatusCode)
	}
	if m.FieldCleared(toolinvocation.FieldDurationMs) {
		fields = append(fields, toolinvocation.FieldDurationMs)
	}
	if m.FieldCleared(toolinvocation.FieldErrorType) {
		fields = append(fields, toolinvocation.FieldErrorType)
	}
	if m.FieldCleared(toolinvocation.FieldErrorMessage) {
		fields = append(fields, toolinvocation.FieldErrorMessage)
	}
	if m.FieldCleared(toolinvocation.FieldEndedAt) {
		fields = append(fields, toolinvocation.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ToolInvocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ClearField(name string) error {
	switch name {
	case toolinvocation.FieldTaskID:
		m.ClearTaskID()
		return nil
	case toolinvocation.FieldToolType:
		m.ClearToolType()
		return nil
	case toolinvocation.FieldTraceID:
		m.ClearTraceID()
		return nil
	case toolinvocation.FieldSpanID:
		m.ClearSpanID()
		return nil
	case toolinvocation.FieldInput:
		m.ClearInput()
		return nil
	case toolinvocation.FieldOutput:
		m.ClearOutput()
		return nil
	case toolinvocation.FieldMetadata:
		m.ClearMetadata()
		return nil
	case toolinvocation.FieldHTTPMethod:
		m.ClearHTTPMethod()
		return nil
	case toolinvocation.FieldHTTPURL:
		m.ClearHTTPURL()
		return nil
	case toolinvocation.FieldHTTPStatusCode:
		m.ClearHTTPStatusCode()
		return nil
	case toolinvocation.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case toolinvocation.FieldErrorType:
		m.ClearErrorType()
		return nil
	case toolinvocation.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case toolinvocation.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ToolInvocationMutation) ResetField(name string) error {
	switch name {
	case toolinvocation.FieldTaskID:
		m.ResetTaskID()
		return nil
	case toolinvocation.FieldAgentID:
		m.ResetAgentID()
		return nil
	case toolinvocation.FieldToolName:
		m.ResetToolName()
		return nil
	case toolinvocation.FieldToolType:
		m.ResetToolType()
		return nil
	case toolinvocation.FieldStatus:
		m.ResetStatus()
		return nil
	case toolinvocation.FieldTraceID:
		m.ResetTraceID()
		return nil
	case toolinvocation.FieldSpanID:
		m.ResetSpanID()
		return nil
	case toolinvocation.FieldInput:
		m.ResetInput()
		return nil
	case toolinvocation.FieldOutput:
		m.ResetOutput()
		return nil
	case toolinvocation.FieldMetadata:
		m.ResetMetadata()
		return nil
	case toolinvocation.FieldHTTPMethod:
		m.ResetHTTPMethod()
		return nil
	case toolinvocation.FieldHTTPURL:
		m.ResetHTTPURL()
		return nil
	case toolinvocation.FieldHTTPStatusCode:
		m.ResetHTTPStatusCode()
		return nil
	case toolinvocation.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case toolinvocation.FieldRequestSizeBytes:
		m.ResetRequestSizeBytes()
		return nil
	case toolinvocation.FieldResponseSizeBytes:
		m.ResetResponseSizeBytes()
		return nil
	case toolinvocation.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case toolinvocation.FieldErrorType:
		m.ResetErrorType()
		return nil
	case toolinvocation.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case toolinvocation.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case toolinvocation.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case toolinvocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case toolinvocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ToolInvocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task != nil {
		edges = append(edges, toolinvocation.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ToolInvocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case toolinvocation.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ToolInvocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ToolInvocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ToolInvocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask {
		edges = append(edges, toolinvocation.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ToolInvocationMutation) EdgeCleared(name string) bool {
	switch name {
	case toolinvocation.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ToolInvocationMutation) ClearEdge(name string) error {
	switch name {
	case toolinvocation.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ToolInvocationMutation) ResetEdge(name string) error {
	switch name {
	case toolinvocation.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown ToolInvocation edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	name                    *string
	status                  *string
	trace_id                *string
	parent_workflow_id      *string
	initiator               *string
	input                   *map[string]interface{}
	output                  *map[string]interface{}
	metadata                *map[string]interface{}
	task_count              *int
	addtask_count           *int
	completed_task_count    *int
	addcompleted_task_count *int
	failed_task_count       *int
	addfailed_task_count    *int
	total_cost_usd          *float64
	addtotal_cost_usd       *float64
	total_tokens            *int
	addtotal_tokens         *int
	duration_ms             *int64
	addduration_ms          *int64
	error_message           *string
	started_at              *time.Time
	ended_at                *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	tasks                   map[string]struct{}
	removedtasks            map[string]struct{}
	clearedtasks            bool
	handoffs                map[string]struct{}
	removedhandoffs         map[string]struct{}
	clearedhandoffs         bool
	events                  map[string]struct{}
	removedevents           map[string]struct{}
	clearedevents           bool
	done                    bool
	oldValue                func(context.Context) (*Workflow, error)
	predicates              []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id string) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *WorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowMutation) ResetStatus() {
	m.status = nil
}

// SetTraceID sets the "trace_id" field.
func (m *WorkflowMutation) SetTraceID(s string) {
	m.trace_id = &s
}

// TraceID returns the value of the "trace_id" field in the mutation.
func (m *WorkflowMutation) TraceID() (r string, exists bool) {
	v := m.trace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTraceID returns the old "trace_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTraceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTraceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTraceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTraceID: %w", err)
	}
	return oldValue.TraceID, nil
}

// ClearTraceID clears the value of the "trace_id" field.
func (m *WorkflowMutation) ClearTraceID() {
	m.trace_id = nil
	m.clearedFields[workflow.FieldTraceID] = struct{}{}
}

// TraceIDCleared returns if the "trace_id" field was cleared in this mutation.
func (m *WorkflowMutation) TraceIDCleared() bool {
	_, ok := m.clearedFields[workflow.FieldTraceID]
	return ok
}

// ResetTraceID resets all changes to the "trace_id" field.
func (m *WorkflowMutation) ResetTraceID() {
	m.trace_id = nil
	delete(m.clearedFields, workflow.FieldTraceID)
}

// SetParentWorkflowID sets the "parent_workflow_id" field.
func (m *WorkflowMutation) SetParentWorkflowID(s string) {
	m.parent_workflow_id = &s
}

// ParentWorkflowID returns the value of the "parent_workflow_id" field in the mutation.
func (m *WorkflowMutation) ParentWorkflowID() (r string, exists bool) {
	v := m.parent_workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentWorkflowID returns the old "parent_workflow_id" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldParentWorkflowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentWorkflowID: %w", err)
	}
	return oldValue.ParentWorkflowID, nil
}

// ClearParentWorkflowID clears the value of the "parent_workflow_id" field.
func (m *WorkflowMutation) ClearParentWorkflowID() {
	m.parent_workflow_id = nil
	m.clearedFields[workflow.FieldParentWorkflowID] = struct{}{}
}

// ParentWorkflowIDCleared returns if the "parent_workflow_id" field was cleared in this mutation.
func (m *WorkflowMutation) ParentWorkflowIDCleared() bool {
	_, ok := m.clearedFields[workflow.FieldParentWorkflowID]
	return ok
}

// ResetParentWorkflowID resets all changes to the "parent_workflow_id" field.
func (m *WorkflowMutation) ResetParentWorkflowID() {
	m.parent_workflow_id = nil
	delete(m.clearedFields, workflow.FieldParentWorkflowID)
}

// SetInitiator sets the "initiator" field.
func (m *WorkflowMutation) SetInitiator(s string) {
	m.initiator = &s
}

// Initiator returns the value of the "initiator" field in the mutation.
func (m *WorkflowMutation) Initiator() (r string, exists bool) {
	v := m.initiator
	if v == nil {
		return
	}
	return *v, true
}

// OldInitiator returns the old "initiator" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldInitiator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitiator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitiator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitiator: %w", err)
	}
	return oldValue.Initiator, nil
}

// ClearInitiator clears the value of the "initiator" field.
func (m *WorkflowMutation) ClearInitiator() {
	m.initiator = nil
	m.clearedFields[workflow.FieldInitiator] = struct{}{}
}

// InitiatorCleared returns if the "initiator" field was cleared in this mutation.
func (m *WorkflowMutation) InitiatorCleared() bool {
	_, ok := m.clearedFields[workflow.FieldInitiator]
	return ok
}

// ResetInitiator resets all changes to the "initiator" field.
func (m *WorkflowMutation) ResetInitiator() {
	m.initiator = nil
	delete(m.clearedFields, workflow.FieldInitiator)
}

// SetInput sets the "input" field.
func (m *WorkflowMutation) SetInput(value map[string]interface{}) {
	m.input = &value
}

// Input returns the value of the "input" field in the mutation.
func (m *WorkflowMutation) Input() (r map[string]interface{}, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldInput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ClearInput clears the value of the "input" field.
func (m *WorkflowMutation) ClearInput() {
	m.input = nil
	m.clearedFields[workflow.FieldInput] = struct{}{}
}

// InputCleared returns if the "input" field was cleared in this mutation.
func (m *WorkflowMutation) InputCleared() bool {
	_, ok := m.clearedFields[workflow.FieldInput]
	return ok
}

// ResetInput resets all changes to the "input" field.
func (m *WorkflowMutation) ResetInput() {
	m.input = nil
	delete(m.clearedFields, workflow.FieldInput)
}

// SetOutput sets the "output" field.
func (m *WorkflowMutation) SetOutput(value map[string]interface{}) {
	m.output = &value
}

// Output returns the value of the "output" field in the mutation.
func (m *WorkflowMutation) Output() (r map[string]interface{}, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldOutput(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *WorkflowMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[workflow.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *WorkflowMutation) OutputCleared() bool {
	_, ok := m.clearedFields[workflow.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *WorkflowMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, workflow.FieldOutput)
}

// SetMetadata sets the "metadata" field.
func (m *WorkflowMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *WorkflowMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *WorkflowMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[workflow.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *WorkflowMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[workflow.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *WorkflowMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, workflow.FieldMetadata)
}

// SetTaskCount sets the "task_count" field.
func (m *WorkflowMutation) SetTaskCount(i int) {
	m.task_count = &i
	m.addtask_count = nil
}

// TaskCount returns the value of the "task_count" field in the mutation.
func (m *WorkflowMutation) TaskCount() (r int, exists bool) {
	v := m.task_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskCount returns the old "task_count" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTaskCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskCount: %w", err)
	}
	return oldValue.TaskCount, nil
}

// AddTaskCount adds i to the "task_count" field.
func (m *WorkflowMutation) AddTaskCount(i int) {
	if m.addtask_count != nil {
		*m.addtask_count += i
	} else {
		m.addtask_count = &i
	}
}

// AddedTaskCount returns the value that was added to the "task_count" field in this mutation.
func (m *WorkflowMutation) AddedTaskCount() (r int, exists bool) {
	v := m.addtask_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskCount resets all changes to the "task_count" field.
func (m *WorkflowMutation) ResetTaskCount() {
	m.task_count = nil
	m.addtask_count = nil
}

// SetCompletedTaskCount sets the "completed_task_count" field.
func (m *WorkflowMutation) SetCompletedTaskCount(i int) {
	m.completed_task_count = &i
	m.addcompleted_task_count = nil
}

// CompletedTaskCount returns the value of the "completed_task_count" field in the mutation.
func (m *WorkflowMutation) CompletedTaskCount() (r int, exists bool) {
	v := m.completed_task_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedTaskCount returns the old "completed_task_count" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCompletedTaskCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedTaskCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedTaskCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedTaskCount: %w", err)
	}
	return oldValue.CompletedTaskCount, nil
}

// AddCompletedTaskCount adds i to the "completed_task_count" field.
func (m *WorkflowMutation) AddCompletedTaskCount(i int) {
	if m.addcompleted_task_count != nil {
		*m.addcompleted_task_count += i
	} else {
		m.addcompleted_task_count = &i
	}
}

// AddedCompletedTaskCount returns the value that was added to the "completed_task_count" field in this mutation.
func (m *WorkflowMutation) AddedCompletedTaskCount() (r int, exists bool) {
	v := m.addcompleted_task_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletedTaskCount resets all changes to the "completed_task_count" field.
func (m *WorkflowMutation) ResetCompletedTaskCount() {
	m.completed_task_count = nil
	m.addcompleted_task_count = nil
}

// SetFailedTaskCount sets the "failed_task_count" field.
func (m *WorkflowMutation) SetFailedTaskCount(i int) {
	m.failed_task_count = &i
	m.addfailed_task_count = nil
}

// FailedTaskCount returns the value of the "failed_task_count" field in the mutation.
func (m *WorkflowMutation) FailedTaskCount() (r int, exists bool) {
	v := m.failed_task_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedTaskCount returns the old "failed_task_count" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldFailedTaskCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedTaskCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedTaskCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedTaskCount: %w", err)
	}
	return oldValue.FailedTaskCount, nil
}

// AddFailedTaskCount adds i to the "failed_task_count" field.
func (m *WorkflowMutation) AddFailedTaskCount(i int) {
	if m.addfailed_task_count != nil {
		*m.addfailed_task_count += i
	} else {
		m.addfailed_task_count = &i
	}
}

// AddedFailedTaskCount returns the value that was added to the "failed_task_count" field in this mutation.
func (m *WorkflowMutation) AddedFailedTaskCount() (r int, exists bool) {
	v := m.addfailed_task_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailedTaskCount resets all changes to the "failed_task_count" field.
func (m *WorkflowMutation) ResetFailedTaskCount() {
	m.failed_task_count = nil
	m.addfailed_task_count = nil
}

// SetTotalCostUsd sets the "total_cost_usd" field.
func (m *WorkflowMutation) SetTotalCostUsd(f float64) {
	m.total_cost_usd = &f
	m.addtotal_cost_usd = nil
}

// TotalCostUsd returns the value of the "total_cost_usd" field in the mutation.
func (m *WorkflowMutation) TotalCostUsd() (r float64, exists bool) {
	v := m.total_cost_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCostUsd returns the old "total_cost_usd" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTotalCostUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCostUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCostUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCostUsd: %w", err)
	}
	return oldValue.TotalCostUsd, nil
}

// AddTotalCostUsd adds f to the "total_cost_usd" field.
func (m *WorkflowMutation) AddTotalCostUsd(f float64) {
	if m.addtotal_cost_usd != nil {
		*m.addtotal_cost_usd += f
	} else {
		m.addtotal_cost_usd = &f
	}
}

// AddedTotalCostUsd returns the value that was added to the "total_cost_usd" field in this mutation.
func (m *WorkflowMutation) AddedTotalCostUsd() (r float64, exists bool) {
	v := m.addtotal_cost_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCostUsd resets all changes to the "total_cost_usd" field.
func (m *WorkflowMutation) ResetTotalCostUsd() {
	m.total_cost_usd = nil
	m.addtotal_cost_usd = nil
}

// SetTotalTokens sets the "total_tokens" field.
func (m *WorkflowMutation) SetTotalTokens(i int) {
	m.total_tokens = &i
	m.addtotal_tokens = nil
}

// TotalTokens returns the value of the "total_tokens" field in the mutation.
func (m *WorkflowMutation) TotalTokens() (r int, exists bool) {
	v := m.total_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokens returns the old "total_tokens" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldTotalTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokens: %w", err)
	}
	return oldValue.TotalTokens, nil
}

// AddTotalTokens adds i to the "total_tokens" field.
func (m *WorkflowMutation) AddTotalTokens(i int) {
	if m.addtotal_tokens != nil {
		*m.addtotal_tokens += i
	} else {
		m.addtotal_tokens = &i
	}
}

// AddedTotalTokens returns the value that was added to the "total_tokens" field in this mutation.
func (m *WorkflowMutation) AddedTotalTokens() (r int, exists bool) {
	v := m.addtotal_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTokens resets all changes to the "total_tokens" field.
func (m *WorkflowMutation) ResetTotalTokens() {
	m.total_tokens = nil
	m.addtotal_tokens = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *WorkflowMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *WorkflowMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDurationMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *WorkflowMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *WorkflowMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *WorkflowMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[workflow.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *WorkflowMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *WorkflowMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, workflow.FieldDurationMs)
}

// SetErrorMessage sets the "error_message" field.
func (m *WorkflowMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *WorkflowMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *WorkflowMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[workflow.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *WorkflowMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[workflow.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *WorkflowMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, workflow.FieldErrorMessage)
}

// SetStartedAt sets the "started_at" field.
func (m *WorkflowMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *WorkflowMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *WorkflowMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *WorkflowMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *WorkflowMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *WorkflowMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[workflow.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *WorkflowMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[workflow.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *WorkflowMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, workflow.FieldEndedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkflowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkflowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkflowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTaskIDs adds the "tasks" edge to the AgentTask entity by ids.
func (m *WorkflowMutation) AddTaskIDs(ids ...string) {
	if m.tasks == nil {
		m.tasks = make(map[string]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the AgentTask entity.
func (m *WorkflowMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the AgentTask entity was cleared.
func (m *WorkflowMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the AgentTask entity by IDs.
func (m *WorkflowMutation) RemoveTaskIDs(ids ...string) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the AgentTask entity.
func (m *WorkflowMutation) RemovedTasksIDs() (ids []string) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *WorkflowMutation) TasksIDs() (ids []string) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *WorkflowMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddHandoffIDs adds the "handoffs" edge to the AgentHandoff entity by ids.
func (m *WorkflowMutation) AddHandoffIDs(ids ...string) {
	if m.handoffs == nil {
		m.handoffs = make(map[string]struct{})
	}
	for i := range ids {
		m.handoffs[ids[i]] = struct{}{}
	}
}

// ClearHandoffs clears the "handoffs" edge to the AgentHandoff entity.
func (m *WorkflowMutation) ClearHandoffs() {
	m.clearedhandoffs = true
}

// HandoffsCleared reports if the "handoffs" edge to the AgentHandoff entity was cleared.
func (m *WorkflowMutation) HandoffsCleared() bool {
	return m.clearedhandoffs
}

// RemoveHandoffIDs removes the "handoffs" edge to the AgentHandoff entity by IDs.
func (m *WorkflowMutation) RemoveHandoffIDs(ids ...string) {
	if m.removedhandoffs == nil {
		m.removedhandoffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.handoffs, ids[i])
		m.removedhandoffs[ids[i]] = struct{}{}
	}
}

// RemovedHandoffs returns the removed IDs of the "handoffs" edge to the AgentHandoff entity.
func (m *WorkflowMutation) RemovedHandoffsIDs() (ids []string) {
	for id := range m.removedhandoffs {
		ids = append(ids, id)
	}
	return
}

// HandoffsIDs returns the "handoffs" edge IDs in the mutation.
func (m *WorkflowMutation) HandoffsIDs() (ids []string) {
	for id := range m.handoffs {
		ids = append(ids, id)
	}
	return
}

// ResetHandoffs resets all changes to the "handoffs" edge.
func (m *WorkflowMutation) ResetHandoffs() {
	m.handoffs = nil
	m.clearedhandoffs = false
	m.removedhandoffs = nil
}

// AddEventIDs adds the "events" edge to the AgentEvent entity by ids.
func (m *WorkflowMutation) AddEventIDs(ids ...string) {
	if m.events == nil {
		m.events = make(map[string]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the AgentEvent entity.
func (m *WorkflowMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the AgentEvent entity was cleared.
func (m *WorkflowMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the AgentEvent entity by IDs.
func (m *WorkflowMutation) RemoveEventIDs(ids ...string) {
	if m.removedevents == nil {
		m.removedevents = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the AgentEvent entity.
func (m *WorkflowMutation) RemovedEventsIDs() (ids []string) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *WorkflowMutation) EventsIDs() (ids []string) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *WorkflowMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkflowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkflowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workflow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkflowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.name != nil {
		fields = append(fields, workflow.FieldName)
	}
	if m.status != nil {
		fields = append(fields, workflow.FieldStatus)
	}
	if m.trace_id != nil {
		fields = append(fields, workflow.FieldTraceID)
	}
	if m.parent_workflow_id != nil {
		fields = append(fields, workflow.FieldParentWorkflowID)
	}
	if m.initiator != nil {
		fields = append(fields, workflow.FieldInitiator)
	}
	if m.input != nil {
		fields = append(fields, workflow.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, workflow.FieldOutput)
	}
	if m.metadata != nil {
		fields = append(fields, workflow.FieldMetadata)
	}
	if m.task_count != nil {
		fields = append(fields, workflow.FieldTaskCount)
	}
	if m.completed_task_count != nil {
		fields = append(fields, workflow.FieldCompletedTaskCount)
	}
	if m.failed_task_count != nil {
		fields = append(fields, workflow.FieldFailedTaskCount)
	}
	if m.total_cost_usd != nil {
		fields = append(fields, workflow.FieldTotalCostUsd)
	}
	if m.total_tokens != nil {
		fields = append(fields, workflow.FieldTotalTokens)
	}
	if m.duration_ms != nil {
		fields = append(fields, workflow.FieldDurationMs)
	}
	if m.error_message != nil {
		fields = append(fields, workflow.FieldErrorMessage)
	}
	if m.started_at != nil {
		fields = append(fields, workflow.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, workflow.FieldEndedAt)
	}
	if m.created_at != nil {
		fields = append(fields, workflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldName:
		return m.Name()
	case workflow.FieldStatus:
		return m.Status()
	case workflow.FieldTraceID:
		return m.TraceID()
	case workflow.FieldParentWorkflowID:
		return m.ParentWorkflowID()
	case workflow.FieldInitiator:
		return m.Initiator()
	case workflow.FieldInput:
		return m.Input()
	case workflow.FieldOutput:
		return m.Output()
	case workflow.FieldMetadata:
		return m.Metadata()
	case workflow.FieldTaskCount:
		return m.TaskCount()
	case workflow.FieldCompletedTaskCount:
		return m.CompletedTaskCount()
	case workflow.FieldFailedTaskCount:
		return m.FailedTaskCount()
	case workflow.FieldTotalCostUsd:
		return m.TotalCostUsd()
	case workflow.FieldTotalTokens:
		return m.TotalTokens()
	case workflow.FieldDurationMs:
		return m.DurationMs()
	case workflow.FieldErrorMessage:
		return m.ErrorMessage()
	case workflow.FieldStartedAt:
		return m.StartedAt()
	case workflow.FieldEndedAt:
		return m.EndedAt()
	case workflow.FieldCreatedAt:
		return m.CreatedAt()
	case workflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldName:
		return m.OldName(ctx)
	case workflow.FieldStatus:
		return m.OldStatus(ctx)
	case workflow.FieldTraceID:
		return m.OldTraceID(ctx)
	case workflow.FieldParentWorkflowID:
		return m.OldParentWorkflowID(ctx)
	case workflow.FieldInitiator:
		return m.OldInitiator(ctx)
	case workflow.FieldInput:
		return m.OldInput(ctx)
	case workflow.FieldOutput:
		return m.OldOutput(ctx)
	case workflow.FieldMetadata:
		return m.OldMetadata(ctx)
	case workflow.FieldTaskCount:
		return m.OldTaskCount(ctx)
	case workflow.FieldCompletedTaskCount:
		return m.OldCompletedTaskCount(ctx)
	case workflow.FieldFailedTaskCount:
		return m.OldFailedTaskCount(ctx)
	case workflow.FieldTotalCostUsd:
		return m.OldTotalCostUsd(ctx)
	case workflow.FieldTotalTokens:
		return m.OldTotalTokens(ctx)
	case workflow.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case workflow.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case workflow.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case workflow.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case workflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflow.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflow.FieldTraceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTraceID(v)
		return nil
	case workflow.FieldParentWorkflowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentWorkflowID(v)
		return nil
	case workflow.FieldInitiator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitiator(v)
		return nil
	case workflow.FieldInput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case workflow.FieldOutput:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case workflow.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case workflow.FieldTaskCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskCount(v)
		return nil
	case workflow.FieldCompletedTaskCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedTaskCount(v)
		return nil
	case workflow.FieldFailedTaskCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedTaskCount(v)
		return nil
	case workflow.FieldTotalCostUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCostUsd(v)
		return nil
	case workflow.FieldTotalTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokens(v)
		return nil
	case workflow.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case workflow.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case workflow.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case workflow.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case workflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	var fields []string
	if m.addtask_count != nil {
		fields = append(fields, workflow.FieldTaskCount)
	}
	if m.addcompleted_task_count != nil {
		fields = append(fields, workflow.FieldCompletedTaskCount)
	}
	if m.addfailed_task_count != nil {
		fields = append(fields, workflow.FieldFailedTaskCount)
	}
	if m.addtotal_cost_usd != nil {
		fields = append(fields, workflow.FieldTotalCostUsd)
	}
	if m.addtotal_tokens != nil {
		fields = append(fields, workflow.FieldTotalTokens)
	}
	if m.addduration_ms != nil {
		fields = append(fields, workflow.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldTaskCount:
		return m.AddedTaskCount()
	case workflow.FieldCompletedTaskCount:
		return m.AddedCompletedTaskCount()
	case workflow.FieldFailedTaskCount:
		return m.AddedFailedTaskCount()
	case workflow.FieldTotalCostUsd:
		return m.AddedTotalCostUsd()
	case workflow.FieldTotalTokens:
		return m.AddedTotalTokens()
	case workflow.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldTaskCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskCount(v)
		return nil
	case workflow.FieldCompletedTaskCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletedTaskCount(v)
		return nil
	case workflow.FieldFailedTaskCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailedTaskCount(v)
		return nil
	case workflow.FieldTotalCostUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCostUsd(v)
		return nil
	case workflow.FieldTotalTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTokens(v)
		return nil
	case workflow.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldTraceID) {
		fields = append(fields, workflow.FieldTraceID)
	}
	if m.FieldCleared(workflow.FieldParentWorkflowID) {
		fields = append(fields, workflow.FieldParentWorkflowID)
	}
	if m.FieldCleared(workflow.FieldInitiator) {
		fields = append(fields, workflow.FieldInitiator)
	}
	if m.FieldCleared(workflow.FieldInput) {
		fields = append(fields, workflow.FieldInput)
	}
	if m.FieldCleared(workflow.FieldOutput) {
		fields = append(fields, workflow.FieldOutput)
	}
	if m.FieldCleared(workflow.FieldMetadata) {
		fields = append(fields, workflow.FieldMetadata)
	}
	if m.FieldCleared(workflow.FieldDurationMs) {
		fields = append(fields, workflow.FieldDurationMs)
	}
	if m.FieldCleared(workflow.FieldErrorMessage) {
		fields = append(fields, workflow.FieldErrorMessage)
	}
	if m.FieldCleared(workflow.FieldEndedAt) {
		fields = append(fields, workflow.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldTraceID:
		m.ClearTraceID()
		return nil
	case workflow.FieldParentWorkflowID:
		m.ClearParentWorkflowID()
		return nil
	case workflow.FieldInitiator:
		m.ClearInitiator()
		return nil
	case workflow.FieldInput:
		m.ClearInput()
		return nil
	case workflow.FieldOutput:
		m.ClearOutput()
		return nil
	case workflow.FieldMetadata:
		m.ClearMetadata()
		return nil
	case workflow.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case workflow.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case workflow.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldName:
		m.ResetName()
		return nil
	case workflow.FieldStatus:
		m.ResetStatus()
		return nil
	case workflow.FieldTraceID:
		m.ResetTraceID()
		return nil
	case workflow.FieldParentWorkflowID:
		m.ResetParentWorkflowID()
		return nil
	case workflow.FieldInitiator:
		m.ResetInitiator()
		return nil
	case workflow.FieldInput:
		m.ResetInput()
		return nil
	case workflow.FieldOutput:
		m.ResetOutput()
		return nil
	case workflow.FieldMetadata:
		m.ResetMetadata()
		return nil
	case workflow.FieldTaskCount:
		m.ResetTaskCount()
		return nil
	case workflow.FieldCompletedTaskCount:
		m.ResetCompletedTaskCount()
		return nil
	case workflow.FieldFailedTaskCount:
		m.ResetFailedTaskCount()
		return nil
	case workflow.FieldTotalCostUsd:
		m.ResetTotalCostUsd()
		return nil
	case workflow.FieldTotalTokens:
		m.ResetTotalTokens()
		return nil
	case workflow.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case workflow.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case workflow.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case workflow.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case workflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tasks != nil {
		edges = append(edges, workflow.EdgeTasks)
	}
	if m.handoffs != nil {
		edges = append(edges, workflow.EdgeHandoffs)
	}
	if m.events != nil {
		edges = append(edges, workflow.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeHandoffs:
		ids := make([]ent.Value, 0, len(m.handoffs))
		for id := range m.handoffs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtasks != nil {
		edges = append(edges, workflow.EdgeTasks)
	}
	if m.removedhandoffs != nil {
		edges = append(edges, workflow.EdgeHandoffs)
	}
	if m.removedevents != nil {
		edges = append(edges, workflow.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeHandoffs:
		ids := make([]ent.Value, 0, len(m.removedhandoffs))
		for id := range m.removedhandoffs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtasks {
		edges = append(edges, workflow.EdgeTasks)
	}
	if m.clearedhandoffs {
		edges = append(edges, workflow.EdgeHandoffs)
	}
	if m.clearedevents {
		edges = append(edges, workflow.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeTasks:
		return m.clearedtasks
	case workflow.EdgeHandoffs:
		return m.clearedhandoffs
	case workflow.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeTasks:
		m.ResetTasks()
		return nil
	case workflow.EdgeHandoffs:
		m.ResetHandoffs()
		return nil
	case workflow.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}
